{
  "name": "React",
  "order": 5,
  "time": "5 hours",
  "helpRoom": "Help",
  "required": [
    {
      "src": "https://unpkg.com/react@16.4.0/umd/react.production.min.js"
    },
    {
      "src": "https://unpkg.com/react-dom@16.4.0/umd/react-dom.production.min.js"
    }
  ],
  "template": "<body><div id='root'></div><div id='challenge-node'></div>${ source || '' }</body>",
  "challenges": [
    {
      "id": "587d7dbc367417b2b2512bb1",
      "title": "Create a Simple JSX Element",
      "releasedOn": "December 25, 2017",
      "description": [
        "<strong>简介：</strong>React 是由 Facebook 创建和维护的开源视图库。它是渲染当代 Web 应用程序用户界面（UI）的绝佳工具。",
        "React 使用名为 JSX 的 JavaScript 语法扩展，允许你直接在 JavaScript 中编写 HTML。这有几个好处。它允许你在 HTML 中使用 JavaScript 的完整程序功能，并有助于保持代码的可读性。在大多数情况下，JSX 类似于你已经学过的 HTML，但是在这些挑战中将会涉及一些关键差异。",
        "例如，因为 JSX 是 JavaScript 的语法扩展，所以你实际上可以直接在 JSX 中编写 JavaScript。要做到这一点，你只需在花括号中包含你希望被视为 JavaScript 的代码：<code>{“这被视为 JavaScript 代码”}</code>。请牢记这个写法，你将会在接下来的挑战中使用。",
        "但是，由于浏览器不能解析 JSX，因此必须将 JSX 代码编译为 JavaScript。在这个过程中，转换器 Babel 是一个很受欢迎的工具。后续挑战已经在后台引入了 Babel，你可以直接写 JSX 代码。如果你的代码不符合 JSX 语法，那么挑战中的第一个测试就不会通过。",
        "值得注意的是，这些挑战在底层调用<code>ReactDOM.render(JSX, document.getElementById('root'))</code>。这个函数调用是将你的 JSX 置于 React 自己的轻量级 DOM 中。然后，React 使用自己的 DOM 快照来优化更新实际 DOM 的特定部分。",
        "<hr>",
        "<strong>说明：</strong>当前代码使用 JSX 将<code>div</code>元素赋值给常量<code>JSX</code>。将<code>div</code>替换为<code>h1</code>元素，并在其中添加文本<code>Hello JSX!</code>。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "const JSX = <div></div>;",
            ""
          ],
          "tail": [
            "ReactDOM.render(JSX, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "常量<code>JSX</code>应该返回一个<code>h1</code>元素。",
          "testString": "assert(JSX.type === 'h1', '常量<code>JSX</code>应该返回一个<code>h1</code>元素。');"
        },
        {
          "text": "<code>h1</code>标签应该包含文本<code>Hello JSX!</code>。",
          "testString": "assert(Enzyme.shallow(JSX).contains('Hello JSX!'), '<code>h1</code>标签应该包含文本<code>Hello JSX!</code>。');"
        }
      ],
      "solutions": [
        "const JSX = <h1>Hello JSX!</h1>;"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24bbe0dba28a8d3cbd4c5d",
      "title": "Create a Complex JSX Element",
      "releasedOn": "December 25, 2017",
      "description": [
        "上一个挑战是 JSX 的一个简单示例，但 JSX 也可以表示更复杂的 HTML。",
        "关于嵌套的 JSX，你需要知道的一件重要的事情，那就是它必须返回单个元素。",
        "这个父元素将包裹所有其他级别的嵌套元素。",
        "例如，几个作为兄弟元素而编写的JSX元素没有父元素包裹将不会被转换。",
        "这里是一个示例：",
        "<b>有效的 JSX：</b>",
        "<blockquote>&lt;div&gt;<br>&nbsp;&nbsp;&lt;p&gt;Paragraph One&lt;/p&gt;<br>&nbsp;&nbsp;&lt;p&gt;Paragraph Two&lt;/p&gt;<br>&nbsp;&nbsp;&lt;p&gt;Paragraph Three&lt;/p&gt;<br>&lt;/div&gt;</blockquote>",
        "<b>无效的 JSX：</b>",
        "<blockquote>&lt;p&gt;Paragraph One&lt;/p&gt;<br>&lt;p&gt;Paragraph Two&lt;/p&gt;<br>&lt;p&gt;Paragraph Three&lt;/p&gt;<br></blockquote>",
        "<hr>",
        "定义一个新的常量<code>JSX</code>，渲染一个<code>div</code>，其中依次包含以下元素：",
        "一个<code>h1</code>，一个<code>p</code>，一个包含三个<code>li</code>项的无序列表。你可以在每个元素中包含任何你想要的文本。",
        "<strong>注意：</strong>&nbsp;当像这样渲染多个元素时，你可以把它们都用圆括号括起来，但是这并不是必须的。还请注意，此挑战使用<code>div</code>标签把所有子元素包裹在里面。如果删除<code>div</code>，JSX 将不会编译这些元素。请记住这一点，因为当你在 React 组件中返回 JSX 元素时它也适用。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// write your code here",
            ""
          ],
          "tail": [
            "ReactDOM.render(JSX, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "常量<code>JSX</code>应该返回一个<code>div</code>元素。",
          "testString": "assert(JSX.type === 'div', '常量<code>JSX</code>应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>p</code>标签作为第二个元素。",
          "testString": "assert(JSX.props.children[1].type === 'p', '<code>div</code>应该包含一个<code>p</code>标签作为第二个元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>ul</code>标签作为第三个元素。",
          "testString": "assert(JSX.props.children[2].type === 'ul', '<code>div</code>应该包含一个<code>ul</code>标签作为第三个元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>h1</code>标签作为第一个元素。",
          "testString": "assert(JSX.props.children[0].type === 'h1', '<code>div</code>应该包含一个<code>h1</code>标签作为第一个元素。');"
        },
        {
          "text": "<code>ul</code>应该包含三个<code>li</code>元素。",
          "testString": "assert(JSX.props.children[2].props.children.length === 3, '<code>ul</code>应该包含三个<code>li</code>元素。');"
        }
      ],
      "solutions": [
        "const JSX = (\n<div>\n  <h1>Hello JSX!</h1>\n  <p>Some info</p>\n  <ul>\n    <li>An item</li>\n    <li>Another item</li>\n    <li>A third item</li>\n  </ul>\n</div>);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24bbe0dba28a8d3cbd4c5e",
      "title": "Add Comments in JSX",
      "releasedOn": "December 25, 2017",
      "description": [
        "JSX 是一种可以编译成有效 JavaScript 的语法。有时，为了便于阅读，你可能需要在代码中添加注释。像大多数编程语言一样，JSX 也有自己的方法来实现这一点。",
        "要将注释放在 JSX 中，可以使用<code>{/* */}</code>语法来包裹注释文本。",
        "<hr>",
        "代码编辑器中的 JSX 元素与你在上一个挑战中创建的元素类似。在提供的<code>div</code>元素中的某处添加注释，而不修改现有的<code>h1</code>或<code>p</code>元素。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const JSX = (",
            "  <div>",
            "    <h1>This is a block of JSX</h1>",
            "    <p>Here's a subtitle</p>",
            "  </div>",
            ");"
          ],
          "tail": [
            "ReactDOM.render(JSX, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "常量<code>JSX</code>应该返回一个<code>div</code>元素。",
          "testString": "assert(JSX.type === 'div', '常量<code>JSX</code>应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>h1</code>标签作为第一个元素。",
          "testString": "assert(JSX.props.children[0].type === 'h1', '<code>div</code>应该包含一个<code>h1</code>标签作为第一个元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>p</code>标签作为第二个元素。",
          "testString": "assert(JSX.props.children[1].type === 'p', '<code>div</code>应该包含一个<code>p</code>标签作为第二个元素。');"
        },
        {
          "text": "<code>JSX</code>应该包含一个注释。",
          "testString": "getUserInput => assert(getUserInput('index').includes('/*') && getUserInput('index').includes('*/'), '<code>JSX</code>应该包含一个注释。');"
        }
      ],
      "solutions": [
        "const JSX = (\n<div>\n  <h1>This is a block of JSX</h1>\n  { /* this is a JSX comment */ }\n  <p>Here's a subtitle</p>\n</div>);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24bbe0dba28a8d3cbd4c5f",
      "title": "Render HTML Elements to the DOM",
      "releasedOn": "December 25, 2017",
      "description": [
        "到目前为止，你已经了解到 JSX 是一种在 JavaScript 中编写可读 HTML 的便捷工具。在 React 中，我们可以使用它的的渲染 API（ReactDOM）将此 JSX 直接渲染到 HTML DOM。",
        "ReactDOM 提供了一个简单的方法来将 React 元素呈现给 DOM，如下所示：<code>ReactDOM.render(componentToRender, targetNode)</code>，其中第一个参数是要渲染的 React 元素或组件，第二个参数是要将组件渲染到的 DOM 节点。",
        "如你所料，必须在 JSX 元素声明之后调用<code>ReactDOM.render()</code>，就像你在使用变量之前必须声明它一样。",
        "<hr>",
        "代码编辑器有一个简单的 JSX 组件。使用<code>ReactDOM.render()</code>方法将该组件渲染到页面。可以将定义好的 JSX 元素直接作为第一个参数传入，并使用<code>document.getElementById()</code>来选择要渲染到的 DOM 节点，在这个挑战中，请渲染到 id 为<code>challenge-node</code>的<code>div</code>中。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const JSX = (",
            "  <div>",
            "    <h1>Hello World</h1>",
            "    <p>Lets render this to the DOM</p>",
            "  </div>",
            ");",
            "// change code below this line",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "常量<code>JSX</code>应该返回一个<code>div</code>元素。",
          "testString": "assert(JSX.type === 'div', '常量<code>JSX</code>应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>h1</code>标签作为第一个元素。",
          "testString": "assert(JSX.props.children[0].type === 'h1', '<code>div</code>应该包含一个<code>h1</code>标签作为第一个元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>p</code>标签作为第二个元素。",
          "testString": "assert(JSX.props.children[1].type === 'p', '<code>div</code>应该包含一个<code>p</code>标签作为第二个元素。');"
        },
        {
          "text": "提供的 JSX 元素应该渲染到 id 为<code>challenge-node</code>的 DOM 节点。",
          "testString": "assert(document.getElementById('challenge-node').childNodes[0].innerHTML === '<h1>Hello World</h1><p>Lets render this to the DOM</p>', '提供的 JSX 元素应该渲染到 id 为<code>challenge-node</code>的 DOM 节点。');"
        }
      ],
      "solutions": [
        "const JSX = (\n<div>\n  <h1>Hello World</h1>\n  <p>Lets render this to the DOM</p>\n</div>\n);\n// change code below this line\nReactDOM.render(JSX, document.getElementById('challenge-node'));"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036160",
      "title": "Define an HTML Class in JSX",
      "releasedOn": "December 25, 2017",
      "description": [
        "现在你已经习惯了编写 JSX，你可能想知道它与 HTML 有什么不同。",
        "到目前为止，HTML 和 JSX 似乎完全相同。",
        "JSX 的一个关键区别是你不能再使用<code>class</code>这个单词来定义 HTML 的 class 名。这是因为<code>class</code>是 JavaScript 中的关键字。JSX 使用<code>className</code>代替。",
        "事实上，JSX 中所有 HTML 属性和事件引用的命名约定都变成了驼峰式。例如，JSX 中的单击事件是 <code>onClick</code>，而不是 <code>onclick</code>。同样，<code>onchange</code>变成了<code>onChange</code>。虽然这是一个微妙的差异，但请你一定要记住。",
        "<hr>",
        "将 class<code>myDiv</code> 应用于 JSX 提供的<code>div</code>上。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const JSX = (",
            "  <div>",
            "    <h1>Add a class to this div</h1>",
            "  </div>",
            ");"
          ],
          "tail": [
            "ReactDOM.render(JSX, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "常量<code>JSX</code>应该返回一个<code>div</code>元素。",
          "testString": "assert.strictEqual(JSX.type, 'div', '常量<code>JSX</code>应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "<code>div</code>有一个<code>myDiv</code>class。",
          "testString": "assert.strictEqual(JSX.props.className, 'myDiv', '<code>div</code>有一个<code>myDiv</code>class。');"
        }
      ],
      "solutions": [
        "const JSX = (\n<div className = 'myDiv'>\n  <h1>Add a class to this div</h1>\n</div>);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036161",
      "title": "Learn About Self-Closing JSX Tags",
      "releasedOn": "December 25, 2017",
      "description": [
        "到目前为止，你已经看到 JSX 与 HTML 的不同之处在于使用<code>className</code>和使用<code>class</code>来定义 HTML 的 class。",
        "JSX 不同于 HTML 的另一个重要方面是自闭合标签。",
        "在HTML中，几乎所有的标签都有一个开始和结束标签：<code>&lt;div&gt;&lt;/div&gt;</code>，结束标签在你要关闭的标签名之前始终具有正斜杠。但是，HTML 中有一些称为“自闭合标签”的特殊实例，它们在另一个标签开始之前，不需要开始和结束标签都存在。",
        "例如，换行标签可以写成<code>&lt;br&gt;</code>或者<code>&lt;br /&gt;</code>，但是不应该写成<code>&lt;br&gt;&lt;/br&gt;</code>，因为它不包含任何内容。",
        "在 JSX 中，规则略有不同。任何 JSX 元素都可以使用自闭合标签编写，并且每个元素都必须关闭。例如，换行标签必须始终编写为<code>&lt;br /&gt;</code>。另一方面<code>&lt;div&gt;</code>可以写成<code>&lt;div /&gt;</code>或者<code>&lt;div&gt;&lt;/div&gt;</code>。不同之处在于，在第一个语法版本中，无法在<code>&lt;div /&gt;</code>中包含任何内容。在后面的挑战中你会发现，这种语法在渲染 React 组件时非常有用。",
        "<hr>",
        "修复代码编辑器中的错误，使其成为有效的 JSX 并成功转换。确保你不更改任何内容--你只需要在需要的地方关闭标签。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const JSX = (",
            "  <div>",
            "    {/* remove comment and change code below this line",
            "    <h2>Welcome to React!</h2> <br >",
            "    <p>Be sure to close all tags!</p>",
            "    <hr >",
            "    remove comment and change code above this line */}",
            "  </div>",
            ");",
            ""
          ],
          "tail": [
            "ReactDOM.render(JSX, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "常量<code>JSX</code>应该返回一个<code>div</code>元素。",
          "testString": "assert.strictEqual(JSX.type, 'div', '常量<code>JSX</code>应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>br</code>标签。",
          "testString": "assert(Enzyme.shallow(JSX).find('br').length === 1, '<code>div</code>应该包含一个<code>br</code>标签。');"
        },
        {
          "text": "<code>div</code>应该包含一个<code>hr</code>标签。",
          "testString": "assert(Enzyme.shallow(JSX).find('hr').length === 1, '<code>div</code>应该包含一个<code>hr</code>标签。');"
        }
      ],
      "solutions": [
        "const JSX = (\n<div>\n  {/* change code below this line */}\n  <h2>Welcome to React!</h2> <br />\n  <p>Be sure to close all tags!</p>\n  <hr />\n  {/* change code above this line */}\n</div>\n);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036162",
      "title": "Create a Stateless Functional Component",
      "releasedOn": "December 25, 2017",
      "description": [
        "组件是 React 的核心。React 中的所有内容都是一个组件，在这里你将学习如何创建一个组件。",
        "有两种方法可以创建 React 组件。第一种方法是使用 JavaScript 函数。以这种方式定义组件会创建<em>无状态功能组件</em>。应用程序中的状态概念将在以后的挑战中介绍。目前，可以将无状态组件视为可以接收数据并对其进行渲染的组件，但是它不管理或跟踪对数据的更改，我们将在下一次挑战中介绍创建 React 组件的第二种方法。",
        "要用函数创建组件，只需编写一个返回 JSX 或<code>null</code>的 JavaScript 函数。需要注意的一点是，React 要求你的函数名以大写字母开头。下面是一个无状态功能组件的示例，该组件在 JSX 中分配一个 HTML 的 class：",
        "<blockquote>// After being transpiled, the &lt;div&gt; will have a CSS class of 'customClass'<br>const DemoComponent = function() {<br>&nbsp;&nbsp;return (<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;div className='customClass' /&gt;<br>&nbsp;&nbsp;);<br>};</blockquote>",
        "因为 JSX 组件代表 HTML，所以你可以将几个组件放在一起以创建更复杂的 HTML 页面，这是 React 提供的组件架构的关键优势之一，它允许你用许多独立的组件组成 UI。这使得构建和维护复杂的用户界面变得更加容易。",
        "<hr>",
        "代码编辑器中有一个名为<code>MyComponent</code>的函数。完成此函数，使其返回包含一些文本字符串的单个<code>div</code>元素。",
        "<strong>注意：</strong>&nbsp;文本被视为是<code>div</code>的子元素，因此你将不能使用自闭合标签。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const MyComponent = function() {",
            "  // change code below this line",
            "",
            "",
            "",
            "  // change code above this line",
            "}"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code>应该返回 JSX。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.length === 1; })(), '<code>MyComponent</code>应该返回 JSX。');"
        },
        {
          "text": "<code>MyComponent</code>应该返回一个<code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.children().type() === 'div' })(), '<code>MyComponent</code>应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "<code>div</code>元素应该包含一个文本字符串。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.find('div').text() !== ''; })(), '<code>div</code>元素应该包含一个文本字符串。');"
        }
      ],
      "solutions": [
        "const MyComponent = function() {\n  // change code below this line\n  return (\n    <div>\n      Demo Solution\n    </div>\n  );\n  // change code above this line\n}"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036163",
      "title": "Create a React Component",
      "releasedOn": "December 25, 2017",
      "description": [
        "定义 React 组件的另一种方法是使用 ES6 的<code>class</code>语法。在以下示例中，<code>Kitten</code>扩展了<code>React.Component</code>：",
        "<blockquote>class Kitten extends React.Component {<br>&nbsp;&nbsp;constructor(props) {<br>&nbsp;&nbsp;&nbsp;&nbsp;super(props);<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;render() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return (<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Hi&lt;/h1&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;);<br>&nbsp;&nbsp;}<br>}</blockquote>",
        "这将创建一个 ES6 类<code>Kitten</code>，它扩展了<code>React.Component</code>类。因此，<code>Kitten</code>类现在可以访问许多有用的 React 功能，例如本地状态和生命周期钩子。如果你还不熟悉这些术语，请不要担心，在以后的挑战中我们将更详细地介绍它们。",
        "另请注意，<code>Kitten</code>类中定义了一个调用<code>super()</code>方法的<code>constructor</code>。它使用<code>super()</code>调用父类的构造函数，即本例中的<code>React.Component</code>。构造函数是使用<code>class</code>关键字创建的特殊方法，它用在实例初始化之前。最佳做法是在组件的<code>constructor</code>里调用<code>super</code>，并将<code>props</code>传递给它们，这样可以保证组件能够正确地初始化。现在，你只需要知道这是标准的做法。很快你会看到构造函数的其他用途以及<code>props</code>。",
        "<hr>",
        "<code>MyComponent</code>是使用类语法在代码编辑器中定义的。完成<code>render</code>方法的编写，使其返回<code>div</code>元素，其中包含文本内容为<code>Hello React!</code>的<code>h1</code>元素。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    // change code below this line",
            "",
            "",
            "",
            "    // change code above this line",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "该 React 组件应该返回一个<code>div</code>元素。",
          "testString": "assert(Enzyme.shallow(React.createElement(MyComponent)).type() === 'div', '该 React 组件应该返回一个<code>div</code>元素。');"
        },
        {
          "text": "返回的<code>div</code>中应该渲染一个<code>h1</code>标题。",
          "testString": "assert(/<div><h1>.*<\\/h1><\\/div>/.test(Enzyme.shallow(React.createElement(MyComponent)).html()), '返回的<code>div</code>中应该渲染一个<code>h1</code>标题。');"
        },
        {
          "text": "<code>h1</code>标题中应该包含字符串<code>Hello React!</code>。",
          "testString": "assert(Enzyme.shallow(React.createElement(MyComponent)).html() === '<div><h1>Hello React!</h1></div>', '<code>h1</code>标题中应该包含字符串<code>Hello React!</code>。');"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    // change code below this line\n    return (\n      <div>\n        <h1>Hello React!</h1>\n      </div>\n    );\n    // change code above this line\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036164",
      "title": "Create a Component with Composition",
      "releasedOn": "December 25, 2017",
      "description": [
        "现在我们来看看如何组合多个 React 组件。想象一下，你正在构建一个应用程序，并创建了三个组件：<code>Navbar</code>、<code>Dashboard</code>和<code>Footer</code>。",
        "要将这些组件组合在一起，你可以创建一个<code>App</code><i>父组件</i>，将这三个组件分别渲染成为<i>子组件</i>。要在 React 组件中渲染一个子组件，你需要在 JSX 中包含作为自定义 HTML 标签编写的组件名称。例如，在<code>render</code>方法中，你可以这样编写：",
        "<blockquote>return (<br> &lt;App&gt;<br>&nbsp;&nbsp;&lt;Navbar /&gt;<br>&nbsp;&nbsp;&lt;Dashboard /&gt;<br>&nbsp;&nbsp;&lt;Footer /&gt;<br> &lt;/App&gt;<br>)</blockquote>",
        "当 React 遇到引用另一个组件的自定义 HTML 标签时（如本例所示，组件名称包含在<code>&lt; /&gt;</code>中），它在标签的位置渲染该组件的标签。这可以说明<code>App</code>组件和<code>Navbar</code>、<code>Dashboard</code>以及<code>Footer</code>之间的父子关系。",
        "<hr>",
        "在代码编辑器中，有一个名为<code>ChildComponent</code>的简单功能组件和一个名为<code>ParentComponent</code>的 React 组件。通过在<code>ParentComponent</code>中渲染<code>ChildComponent</code>来将两者组合在一起。确保使用正斜杠关闭<code>ChildComponent</code>标签。",
        "<strong>注意：</strong>&nbsp;<code>ChildComponent</code>是使用 ES6 的箭头函数定义的，因为这是使用 React 时非常常见的做法。但是，要知道这只是一个函数。如果你不熟悉箭头函数语法，请参阅 JavaScript 部分。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const ChildComponent = () => {",
            "  return (",
            "    <div>",
            "      <p>I am the child</p>",
            "    </div>",
            "  );",
            "};",
            "",
            "class ParentComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>I am the parent</h1>",
            "        { /* change code below this line */ }",
            "",
            "",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<ParentComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "React 组件应该返回单个<code>div</code>元素。",
          "testString": "assert((function() { var shallowRender = Enzyme.shallow(React.createElement(ParentComponent)); return shallowRender.type() === 'div'; })(), 'React 组件应该返回单个<code>div</code>元素。');"
        },
        {
          "text": "组件应该返回两个嵌套的元素。",
          "testString": "assert((function() { var shallowRender = Enzyme.shallow(React.createElement(ParentComponent)); return shallowRender.children().length === 2; })(), '组件应该返回两个嵌套的元素。');"
        },
        {
          "text": "组件的第二个子元素应该是 ChildComponent。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ParentComponent)); return mockedComponent.find('ParentComponent').find('ChildComponent').length === 1; })(), '组件的第二个子元素应该是 ChildComponent。');"
        }
      ],
      "solutions": [
        "const ChildComponent = () => {\n  return (\n    <div>\n      <p>I am the child</p>\n    </div>\n  );\n};\n\nclass ParentComponent extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h1>I am the parent</h1>\n        { /* change code below this line */ }\n        <ChildComponent />\n        { /* change code above this line */ }\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036165",
      "title": "Use React to Render Nested Components",
      "releasedOn": "December 25, 2017",
      "description": [
        "上一个挑战显示了组合两个组件的简单方法，但是有许多不同的方法可以把 React 组件组合在一起。",
        "组件组合是 React 的强大功能之一。当你使用 React 时，应当先用组件的思路考虑清楚用户界面的结构（如上一个挑战中的 App 示例）。可以将 UI 分解为基本的构建块，这些构建块就是组件。这样做有助于将负责 UI 的代码与负责处理应用程序逻辑的代码分开，并可以大大简化复杂项目的开发和维护。",
        "<hr>",
        "代码编辑器中定义了两个功能组件，分别是<code>TypesOfFruit</code>和<code>Fruits</code>。请把<code>TypesOfFruit</code>组件放到<code>Fruits</code>组件中，然后把<code>Fruits</code>组件放到<code>TypesOfFood</code>组件中。结果应该是子组件嵌套在父组件中，父组件嵌套在它本身的父组件中！"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const TypesOfFruit = () => {",
            "  return (",
            "    <div>",
            "      <h2>Fruits:</h2>",
            "      <ul>",
            "        <li>Apples</li>",
            "        <li>Blueberries</li>",
            "        <li>Strawberries</li>",
            "        <li>Bananas</li>",
            "      </ul>",
            "    </div>",
            "  );",
            "};",
            "",
            "const Fruits = () => {",
            "  return (",
            "    <div>",
            "      { /* change code below this line */ }",
            "",
            "      { /* change code above this line */ }",
            "    </div>",
            "  );",
            "};",
            "",
            "class TypesOfFood extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>Types of Food:</h1>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<TypesOfFood />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>TypesOfFood</code>组件应该返回单个<code>div</code>元素。",
          "testString": "assert(Enzyme.shallow(React.createElement(TypesOfFood)).type() === 'div', '<code>TypesOfFood</code>组件应该返回单个<code>div</code>元素。');"
        },
        {
          "text": "<code>TypesOfFood</code>组件应该返回<code>Fruits</code>组件。",
          "testString": "assert(Enzyme.shallow(React.createElement(TypesOfFood)).props().children[1].type.name === 'Fruits', '<code>TypesOfFood</code>组件应该返回<code>Fruits</code>组件。');"
        },
        {
          "text": "<code>Fruits</code>组件应该返回<code>TypesOfFruit</code>组件。",
          "testString": "assert(Enzyme.mount(React.createElement(TypesOfFood)).find('h2').html() === '<h2>Fruits:</h2>', '<code>Fruits</code>组件应该返回<code>TypesOfFruit</code>组件。');"
        },
        {
          "text": "<code>TypesOfFruit</code>组件应该返回<code>h2</code>和<code>ul</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(TypesOfFood)).find('ul').text() === 'ApplesBlueberriesStrawberriesBananas', '<code>TypesOfFruit</code>组件应该返回<code>h2</code>和<code>ul</code>元素。');"
        }
      ],
      "solutions": [
        "const TypesOfFruit = () => {\n  return (\n    <div>\n      <h2>Fruits:</h2>\n      <ul>\n        <li>Apples</li>\n        <li>Blueberries</li>\n        <li>Strawberries</li>\n        <li>Bananas</li>\n      </ul>\n    </div>\n  );\n};\n\nconst Fruits = () => {\n  return (\n    <div>\n      { /* change code below this line */ }\n        <TypesOfFruit />\n      { /* change code above this line */ }\n    </div>\n  );\n};\n\nclass TypesOfFood extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n\n  render() {\n    return (\n      <div>\n        <h1>Types of Food:</h1>\n        { /* change code below this line */ }\n        <Fruits />\n        { /* change code above this line */ }\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036166",
      "title": "Compose React Components",
      "releasedOn": "December 25, 2017",
      "description": [
        "随着挑战继续，我们将组合使用更复杂的 React 组件和 JSX，有一点需要注意。在其他组件中渲染 ES6 风格的类组件和渲染你在过去几个挑战中使用的简单组件没有什么不同。你可以在其他组件中渲染 JSX 元素、无状态功能组件和 ES6 类组件。",
        "<hr>",
        "在代码编辑器中，<code>TypesOfFood</code>组件已经渲染了一个名为<code>Vegetables</code>的组件。此外，还有上次挑战中的<code>Fruits</code>组件。",
        "在<code>Fruits</code>中嵌套两个组件，首先<code>NonCitrus</code>，然后是<code>Citrus</code>，这两个组件都是在后台为你提供的。接下来，将<code>Fruits</code>类组件嵌到<code>TypesOfFood</code>组件中，位于<code>h1</code>标题下方和<code>Vegetables</code>上方。结果应该是一系列嵌套的组件，它们使用两种不同的组件类型。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "head": [
            "class NonCitrus extends React.Component {",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h4>Non-Citrus:</h4>",
            "        <ul>",
            "          <li>Apples</li>",
            "          <li>Blueberries</li>",
            "          <li>Strawberries</li>",
            "          <li>Bananas</li>",
            "        </ul>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "class Citrus extends React.Component {",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h4>Citrus:</h4>",
            "        <ul>",
            "          <li>Lemon</li>",
            "          <li>Lime</li>",
            "          <li>Orange</li>",
            "          <li>Grapefruit</li>",
            "        </ul>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "class Vegetables extends React.Component {",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h2>Vegetables:</h2>",
            "        <ul>",
            "          <li>Brussel Sprouts</li>",
            "          <li>Broccoli</li>",
            "          <li>Squash</li>",
            "        </ul>",
            "      </div>",
            "    );",
            "     }",
            "};"
          ],
          "contents": [
            "class Fruits extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h2>Fruits:</h2>",
            "        { /* change code below this line */ }",
            "",
            "         { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};",
            "",
            "class TypesOfFood extends React.Component {",
            "  constructor(props) {",
            "     super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>Types of Food:</h1>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "        <Vegetables />",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<TypesOfFood />, document.getElementById('root'))"
          ]
        }
      },
      "tests": [
        {
          "text": "<code>TypesOfFood</code>组件应该返回单个<code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return mockedComponent.children().type() === 'div'; })(), '<code>TypesOfFood</code>组件应该返回单个<code>div</code>元素。');"
        },
        {
          "text": "<code>TypesOfFood</code>组件应该返回<code>Fruits</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return mockedComponent.children().childAt(1).name() === 'Fruits'; })(), '<code>TypesOfFood</code>组件应该返回<code>Fruits</code>组件。');"
        },
        {
          "text": "<code>Fruits</code>组件应该返回<code>NonCitrus</code>组件和<code>Citrus</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return (mockedComponent.find('Fruits').children().find('NonCitrus').length === 1 && mockedComponent.find('Fruits').children().find('Citrus').length === 1); })(), '<code>Fruits</code>组件应该返回<code>NonCitrus</code>组件和<code>Citrus</code>组件。');"
        },
        {
          "text": "<code>TypesOfFood</code>组件应该返回<code>Vegetables</code>组件，且其位于<code>Fruits</code>组件之下。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return mockedComponent.children().childAt(2).name() === 'Vegetables'; })(), '<code>TypesOfFood</code>组件应该返回<code>Vegetables</code>组件，且其位于<code>Fruits</code>组件之下。');"
        }
      ],
      "solutions": [
        "class Fruits extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h2>Fruits:</h2>\n        { /* change code below this line */ }\n        <NonCitrus />\n        <Citrus />\n        { /* change code above this line */ }\n      </div>\n    )\n  }\n}\n\nclass TypesOfFood extends React.Component {\n  constructor(props) {\n     super(props);\n  }\n    render() {\n      return (\n        <div>\n        <h1>Types of Food:</h1>\n          { /* change code below this line */ }\n          <Fruits />\n          { /* change code above this line */ }\n          <Vegetables />\n        </div>\n      );\n    }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036167",
      "title": "Render a Class Component to the DOM",
      "releasedOn": "December 25, 2017",
      "description": [
        "你可能还记得在早期挑战中使用 ReactDOM API 将 JSX 元素渲染到 DOM，这与渲染 React 组件的过程十分相似。过去的几个挑战主要针对组件和组合，因此渲染是在幕后为你完成的。但是，如果不调用 ReactDOM API，你编写的任何 React 代码都不会渲染到 DOM。",
        "以下是语法的复习：<code>ReactDOM.render(componentToRender, targetNode)</code>。第一个参数是要渲染的 React 组件。第二个参数是要在其中渲染该组件的 DOM 节点。",
        "React 组件传递到<code>ReactDOM.render()</code>与 JSX 元素略有不同。对于 JSX 元素，你传入的是要渲染的元素的名称。但是，对于 React 组件，你需要使用与渲染嵌套组件相同的语法，例如<code>ReactDOM.render(&lt;ComponentToRender /&gt;, targetNode)</code>。你可以将此语法用于ES6类组件和函数组件。",
        "<hr>",
        "在后台为你定义了<code>Fruits</code>和<code>Vegetables</code>组件。将两个组件渲染为<code>TypesOfFood</code>组件的子组件，然后将<code>TypesOfFood</code>渲染到 DOM 节点，在这个挑战中，请渲染到 id 为<code>challenge-node</code>的<code>div</code>中。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "head": [
            "",
            "const Fruits = () => {",
            "  return (",
            "    <div>",
            "      <h2>Fruits:</h2>",
            "      <h4>Non-Citrus:</h4>",
            "        <ul>",
            "          <li>Apples</li>",
            "          <li>Blueberries</li>",
            "          <li>Strawberries</li>",
            "          <li>Bananas</li>",
            "        </ul>",
            "      <h4>Citrus:</h4>",
            "        <ul>",
            "          <li>Lemon</li>",
            "          <li>Lime</li>",
            "          <li>Orange</li>",
            "          <li>Grapefruit</li>",
            "        </ul>",
            "    </div>",
            "  );",
            "};",
            "const Vegetables = () => {",
            "  return (",
            "    <div>",
            "      <h2>Vegetables:</h2>",
            "      <ul>",
            "        <li>Brussel Sprouts</li>",
            "        <li>Broccoli</li>",
            "        <li>Squash</li>",
            "      </ul>",
            "    </div>",
            "  );",
            "};",
            ""
          ],
          "contents": [
            "",
            "class TypesOfFood extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>Types of Food:</h1>",
            "        {/* change code below this line */}",
            "",
            "        {/* change code above this line */}",
            "      </div>",
            "    );",
            "  }",
            "};",
            "",
            "// change code below this line",
            ""
          ],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "<code>TypesOfFood</code>组件应该返回单个<code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return mockedComponent.children().type() === 'div'; })(), '<code>TypesOfFood</code>组件应该返回单个<code>div</code>元素。');"
        },
        {
          "text": "<code>TypesOfFood</code>组件应该在<code>h1</code>元素之后渲染<code>Fruits</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return mockedComponent.children().childAt(1).name() === 'Fruits'; })(), '<code>TypesOfFood</code>组件应该在<code>h1</code>元素之后渲染<code>Fruits</code>组件。');"
        },
        {
          "text": "<code>TypesOfFood</code>组件应该在<code>Fruits</code>组件之后渲染<code>Vegetables</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(TypesOfFood)); return mockedComponent.children().childAt(2).name() === 'Vegetables'; })(), '<code>TypesOfFood</code>组件应该在<code>Fruits</code>组件之后渲染<code>Vegetables</code>组件。');"
        },
        {
          "text": "<code>TypesOfFood</code>组件应该渲染到 id 为<code>challenge-node</code>的<code>div</code>中。",
          "testString": "assert((function() { const html = document.getElementById('challenge-node').childNodes[0].innerHTML; return (html === '<h1>Types of Food:</h1><div><h2>Fruits:</h2><h4>Non-Citrus:</h4><ul><li>Apples</li><li>Blueberries</li><li>Strawberries</li><li>Bananas</li></ul><h4>Citrus:</h4><ul><li>Lemon</li><li>Lime</li><li>Orange</li><li>Grapefruit</li></ul></div><div><h2>Vegetables:</h2><ul><li>Brussel Sprouts</li><li>Broccoli</li><li>Squash</li></ul></div>'); })(), '<code>TypesOfFood</code>组件应该渲染到 id 为<code>challenge-node</code>的<code>div</code>中。');"
        }
      ],
      "solutions": [
        "class TypesOfFood extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h1>Types of Food:</h1>\n        {/* change code below this line */}\n          <Fruits />\n           <Vegetables />\n         {/* change code above this line */}\n      </div>\n    );\n  }\n};\n\n// change code below this line\nReactDOM.render(<TypesOfFood />, document.getElementById('challenge-node'));"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036168",
      "title": "Write a React Component from Scratch",
      "releasedOn": "December 25, 2017",
      "description": [
        "现在你已经了解了 JSX 和 React 组件的基础知识，现在是时候自己编写一个组件了。React 组件是 React 应用程序的核心组成部分，因此熟练编写它们是非常重要的。记住，典型的 React 组件是 ES6<code>class</code>，它扩展了<code>React.Component</code>。它有一个返回 HTML（从 JSX 返回）或<code>null</code>的渲染方法，这是 React 组件的基本形式。一旦你深刻地理解了这一点，你就可以开始构建更复杂的 React 项目了。",
        "<hr>",
        "定义一个<code>MyComponent</code>类，它是<code>React.Component</code>的扩展。它的渲染方法应该返回一个<code>div</code>，其中包含一个<code>h1</code>标签，标签文本为：<code>My First React Component!</code>。请确保文本内容、大小写和标点符号正确，以及调用了组件的构造函数。",
        "使用<code>ReactDOM.render()</code>把该组件渲染到 DOM 中。有一个<code>id='challenge-node'</code>的<code>div</code>可供你使用。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "// change code below this line",
            ""
          ],
          "head": [],
          "tail": []
        }
      },
      "tests": [
        {
          "text": "应该有一个名为<code>MyComponent</code>的React组件。",
          "testString": "getUserInput => assert(getUserInput('index').replace(/\\s/g, '').includes('classMyComponentextendsReact.Component{'), '应该有一个名为<code>MyComponent</code>的React组件。');"
        },
        {
          "text": "<code>MyComponent</code>应该包含一个<code>h1</code>标签，标签的文本为<code>My First React Component!</code>，区分大小写并有标点符号。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.find('h1').text() === 'My First React Component!'; })(), '<code>MyComponent</code>应该包含一个<code>h1</code>标签，标签的文本为<code>My First React Component!</code>，区分大小写并有标点符号。');"
        },
        {
          "text": "<code>MyComponent</code>应该渲染到 DOM。",
          "testString": "assert(document.getElementById('challenge-node').childNodes.length === 1, '<code>MyComponent</code>应该渲染到 DOM。');"
        }
      ],
      "solutions": [
        "// change code below this line\nclass MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h1>My First React Component!</h1>\n      </div>\n    );\n  }\n};\n\nReactDOM.render(<MyComponent />, document.getElementById('challenge-node'));"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036169",
      "title": "Pass Props to a Stateless Functional Component",
      "releasedOn": "December 25, 2017",
      "description": [
        "之前的挑战涵盖了关于在 React 中创建和组合 JSX 元素、函数组件和 ES6 风格的类组件的很多内容。有了这个基础，现在是时候看看 React 中的另一个常见特性 <b>props</b> 了。在 React 中，你可以将属性传递给子组件。假设你有一个<code>App</code>组件，该组件渲染了一个名为<code>Welcome</code>的子组件，它是一个无状态函数组件。你可以通过以下方式给<code>Welcome</code>传递一个<code>user</code>属性：",
        "<blockquote>&lt;App&gt;<br>&nbsp;&nbsp;&lt;Welcome user='Mark' /&gt;<br>&lt;/App&gt;</blockquote>",
        "使用<strong>自定义 HTML 属性</strong>，React 支持将属性<code>user</code>传递给组件<code>Welcome</code>。由于<code>Welcome</code>是一个无状态函数组件，它可以像这样访问该值：",
        "<blockquote>const Welcome = (props) => &lt;h1&gt;Hello, {props.user}!&lt;/h1&gt;</blockquote>",
        "调用<code>props</code>这个值是常见做法，当处理无状态函数组件时，你基本上可以将其视为返回 JSX 的函数的参数。这样，你就可以在函数体中访问该值。但对于类组件，访问方式会略有不同。",
        "<hr>",
        "代码编辑器中有<code>Calendar</code>和<code>CurrentDate</code>组件。从<code>Calendar</code>组件渲染<code>CurrentDate</code>时，从 JavaScript 的<code>Date</code>对象分配当前日期，并将其作为<code>date</code>属性传入。然后访问<code>CurrentDate</code>组件的<code>prop</code>，并在<code>p</code>标签中显示其值。请注意，要将<code>prop</code>的值视为 JavaScript，必须将它们括在花括号中，例如<code>date={Date()}</code>。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "const CurrentDate = (props) => {",
            "  return (",
            "    <div>",
            "      { /* change code below this line */ }",
            "      <p>The current date is: </p>",
            "      { /* change code above this line */ }",
            "    </div>",
            "  );",
            "};",
            "",
            "class Calendar extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h3>What date is it?</h3>",
            "        { /* change code below this line */ }",
            "        <CurrentDate />",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<Calendar />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>Calendar</code>组件应该返回单个<code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Calendar)); return mockedComponent.children().type() === 'div'; })(), '<code>Calendar</code>组件应该返回单个<code>div</code>元素。');"
        },
        {
          "text": "<code>Calendar</code>组件的第二个子元素应该是<code>CurrentDate</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Calendar)); return mockedComponent.children().childAt(1).name() === 'CurrentDate'; })(), '<code>Calendar</code>组件的第二个子元素应该是<code>CurrentDate</code>组件。');"
        },
        {
          "text": "<code>CurrentDate</code>组件应该有一个名为<code>date</code>的属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Calendar)); return mockedComponent.children().childAt(1).props().date })(), '<code>CurrentDate</code>组件应该有一个名为<code>date</code>的属性。');"
        },
        {
          "text": "<code>CurrentDate</code>的<code>date</code>属性应该包含一段文本字符串。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Calendar)); const prop = mockedComponent.children().childAt(1).props().date; return( typeof prop === 'string' && prop.length > 0 ); })(), '<code>CurrentDate</code>的<code>date</code>属性应该包含一段文本字符串。');"
        },
        {
          "text": "<code>CurrentDate</code>组件应该把<code>date</code>属性渲染在<code>p</code>标签内。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Calendar)); return mockedComponent.find('p').html().includes(Date().substr(3)); })(), '<code>CurrentDate</code>组件应该把<code>date</code>属性渲染在<code>p</code>标签内。');"
        }
      ],
      "solutions": [
        "const CurrentDate = (props) => {\n  return (\n    <div>\n      { /* change code below this line */ }\n      <p>The current date is: {props.date}</p>\n      { /* change code above this line */ }\n    </div>\n  );\n};\n\nclass Calendar extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h3>What date is it?</h3>\n        { /* change code below this line */ }\n        <CurrentDate date={Date()} />\n        { /* change code above this line */ }\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403616a",
      "title": "Pass an Array as Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "上一个挑战演示了如何将来自父组件的信息作为<code>props</code>传递给子组件。这个挑战着眼于如何将数组作为<code>props</code>传递。要将数组传递给 JSX 元素，必须将其视为 JavaScript 并用花括号括起来。",
        "<blockquote>&lt;ParentComponent&gt;<br>&nbsp;&nbsp;&lt;ChildComponent colors={[\"green\", \"blue\", \"red\"]} /&gt;<br>&lt;/ParentComponent&gt;</blockquote>",
        "这样，子组件就可以访问数组属性<code>colors</code>。访问属性时可以使用<code>join()</code>等数组方法。",
        "<code>const ChildComponent = (props) => &lt;p&gt{props.colors.join(', ')}&lt;/p&gt</code>",
        "这将把所有<code>colors</code>数组项连接成一个逗号分隔的字符串并生成：",
        " <code> &lt;p&gt;green, blue, red&lt;/p&gt;</code>",
        "稍后，我们将了解在 React 中渲染数组数据的其他常用方法。",
        "<hr>",
        "代码编辑器中有<code>List</code>和<code>ToDo</code>组件。在<code>ToDo</code>组件中渲染每个<code>List</code>时，传入<code>tasks</code>属性并将其分配给待办任务数组，例如<code>[\"walk dog\", \"workout\"]</code>。然后访问<code>List</code>组件中的<code>tasks</code>数组，在<code>p</code>元素中显示其值。使用<code>join(\", \")</code>把<code>props.tasks</code>数组作为逗号分隔列表显示在<code>p</code>元素中。今天的列表应该至少有 2 个任务，明天应该至少有 3 个任务。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const List= (props) => {",
            "  { /* change code below this line */ }",
            "  return <p>{}</p>",
            "  { /* change code above this line */ }",
            "};",
            "",
            "class ToDo extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>To Do Lists</h1>",
            "        <h2>Today</h2>",
            "        { /* change code below this line */ }",
            "        <List/>",
            "        <h2>Tomorrow</h2>",
            "        <List/>",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<ToDo />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>ToDo</code>组件应该返回单个外部<code>div</code>。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return mockedComponent.children().first().type() === 'div'; })(), '<code>ToDo</code>组件应该返回单个外部<code>div</code>。');"
        },
        {
          "text": "<code>ToDo</code>组件的第三个子元素应该是<code>List</code>组件的一个实例。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return mockedComponent.children().first().childAt(2).name() === 'List'; })(), '<code>ToDo</code>组件的第三个子元素应该是<code>List</code>组件的一个实例。');"
        },
        {
          "text": "<code>ToDo</code>组件的第五个子元素应该是<code>List</code>组件的一个实例。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return mockedComponent.children().first().childAt(4).name() === 'List'; })(), '<code>ToDo</code>组件的第五个子元素应该是<code>List</code>组件的一个实例。');"
        },
        {
          "text": "<code>List</code>组件的两个实例都应该具有一个名为<code>tasks</code>的属性，并且<code>tasks</code>的类型应该是数组。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return Array.isArray(mockedComponent.find('List').get(0).props.tasks) && Array.isArray(mockedComponent.find('List').get(1).props.tasks); })(), '<code>List</code>组件的两个实例都应该具有一个名为<code>tasks</code>的属性，并且<code>tasks</code>的类型应该是数组。');"
        },
        {
          "text": "表示今天任务的第一个<code>List</code>组件应该有 2 个或更多项。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return mockedComponent.find('List').get(0).props.tasks.length >= 2; })(), '表示今天任务的第一个<code>List</code>组件应该有 2 个或更多项。');"
        },
        {
          "text": "表示明天任务的第二个<code>List</code>组件应该有 3 个或更多项。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return mockedComponent.find('List').get(1).props.tasks.length >= 3; })(), '表示明天任务的第二个<code>List</code>组件应该有 3 个或更多项。');"
        },
        {
          "text": "<code>List</code>组件应在<code>p</code>标签中渲染<code>tasks</code>属性的值。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ToDo)); return mockedComponent.find('p').get(0).props.children === mockedComponent.find('List').get(0).props.tasks.join(', ') && mockedComponent.find('p').get(1).props.children === mockedComponent.find('List').get(1).props.tasks.join(', '); })(), '<code>List</code>组件应在<code>p</code>标签中渲染<code>tasks</code>属性的值。');"
        }
      ],
      "solutions": [
        "const List= (props) => {\n  return <p>{props.tasks.join(', ')}</p>\n};\n\nclass ToDo extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h1>To Do Lists</h1>\n        <h2>Today</h2>\n        <List tasks={['study', 'exercise']} />\n        <h2>Tomorrow</h2>\n        <List tasks={['call Sam', 'grocery shopping', 'order tickets']} />\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403616b",
      "title": "Use Default Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "React 还有一个设置默认 props 的选项。你可以将默认 props 作为组件本身的属性分配给组件，React 会在必要时分配默认 prop。如果没有显式的提供任何值，这允许你指定 prop 值应该是什么。例如，如果你声明<code>MyComponent.defaultProps = { location: 'San Francisco' }</code>，即定义一个 location 属性，并且其值在没有另行制定的情况下被设置为字符串<code>San Francisco</code>。如果 props 未定义，则 React 会分配默认 props，但如果你将<code>null</code>作为 prop 的值，它将保持<code>null</code>。",
        "<hr>",
        "代码编辑器中有一个<code>ShoppingCart</code>组件。在这个组件上定义默认 props，它指定一个<code>items</code>prop，其值为<code>0</code>。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const ShoppingCart = (props) => {",
            "  return (",
            "    <div>",
            "      <h1>Shopping Cart Component</h1>",
            "    </div>",
            "  )",
            "};",
            "// change code below this line",
            ""
          ],
          "tail": [
            "ReactDOM.render(<ShoppingCart />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "应该渲染<code>ShoppingCart</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); return mockedComponent.find('ShoppingCart').length === 1; })(), '应该渲染<code>ShoppingCart</code>组件。');"
        },
        {
          "text": "<code>ShoppingCart</code>组件应该有一个<code>{ items: 0 }</code>的默认 prop。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); mockedComponent.setProps({items: undefined}); return mockedComponent.find('ShoppingCart').props().items === 0; })(), '<code>ShoppingCart</code>组件应该有一个<code>{ items: 0 }</code>的默认 prop。');"
        }
      ],
      "solutions": [
        "const ShoppingCart = (props) => {\n  return (\n    <div>\n      <h1>Shopping Cart Component</h1>\n    </div>\n  )\n};\n\n// change code below this line\nShoppingCart.defaultProps = {\n  items: 0\n}"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403616c",
      "title": "Override Default Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "在 React 中，设置默认的 props 是一个很有用的特性，显式设置组件的 prop 值即可覆盖默认 props。",
        "<hr>",
        "<code>ShoppingCart</code>组件现在渲染了一个子组件<code>Items</code>。该<code>Items</code>组件有一个默认<code>quantity</code>prop，其值被设置为整数<code>0</code>。通过传入数值<code>10</code>来覆盖<code>quantity</code>的默认 prop。",
        "<strong>注意：</strong>&nbsp;请记住，向组件添加 prop 的语法与添加 HTML 属性类似。但是，由于<code>quantity</code>的值是整数，所以它不会加引号，但应该用花括号括起来，例如<code>{100}</code>。这个语法告诉 JSX 直接将花括号中的值解释为 JavaScript。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const Items = (props) => {",
            "  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>",
            "}",
            "",
            "Items.defaultProps = {",
            "  quantity: 0",
            "}",
            "",
            "class ShoppingCart extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    { /* change code below this line */ }",
            "    return <Items />",
            "    { /* change code above this line */ }",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<ShoppingCart />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "应该渲染<code>ShoppingCart</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); return mockedComponent.find('ShoppingCart').length === 1; })(), '应该渲染<code>ShoppingCart</code>组件。');"
        },
        {
          "text": "应该渲染<code>Items</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); return mockedComponent.find('Items').length === 1; })(), '应该渲染<code>Items</code>组件。');"
        },
        {
          "text": "<code>Items</code>组件应该有一个<code>{ quantity: 10 }</code>的prop，该 prop 是从<code>ShoppingCart</code>组件传递过去的。",
          "testString": "getUserInput => assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); return mockedComponent.find('Items').props().quantity == 10 && getUserInput('index').replace(/ /g,'').includes('<Itemsquantity={10}/>'); })(), '<code>Items</code>组件应该有一个<code>{ quantity: 10 }</code>的prop，该 prop 是从<code>ShoppingCart</code>组件传递过去的。');"
        }
      ],
      "solutions": [
        "const Items = (props) => {\n  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>\n}\n\nItems.defaultProps = {\n  quantity: 0\n}\n\nclass ShoppingCart extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    { /* change code below this line */ }\n    return <Items quantity = {10} />\n    { /* change code above this line */ }\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403616d",
      "title": "Use PropTypes to Define the Props You Expect",
      "releasedOn": "December 25, 2017",
      "description": [
        "React 提供了有用的类型检查特性，以验证组件是否接收了正确类型的 props。例如，你的应用程序调用 API 来检索你希望在数组中的数据，然后将数据作为 prop 传递给组件。你可以在组件上设置<code>propTypes</code>，以要求数据的类型为<code>array</code>。当数据是任何其他类型时，都会抛出警告。",
        "当你提前知道 prop 的类型时，最好的做法是设置<code>propTypes</code>。可以为组件定义<code>propTypes</code>属性，方法与定义<code>defaultProps</code>相同。这样做将检查给定键的 prop 是否是给定类型。这里有一个示例，名为<code>handleClick</code>的 prop 应为<code>function</code>类型：",
        "<code>MyComponent.propTypes = { handleClick: PropTypes.func.isRequired }</code>",
        "在上面的示例中，<code>PropTypes.func</code>部分检查<code>handleClick</code>是否为函数。添加<code>isRequired</code>是为了告诉 React<code>handleClick</code>是该组件的必需属性。如果未提供该 prop，你将看到警告信息。另请注意，<code>func</code>表示<code>function</code>。在 7 种 JavaScript 基本类型中，<code>function</code>和<code>boolean</code>（写为<code>bool</code>）是仅有的使用异常拼写的两种类型。除了基本类型，还有其他类型可用。例如，你可以检查 prop 是否为 React 组件，请参阅文档以获取所有选项。",
        "<strong>注意：</strong>在 React v15.5.0 版本中, <code>PropTypes</code>可以从 React 中单独引入，如下所示：",
        "<code>import React, { PropTypes } from 'react';</code>",
        "<hr>",
        "为<code>Items</code>组件定义<code>propTypes</code>，要求<code>quantity</code>作为 prop，并验证它是<code>number</code>类型。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "head": [
            "var PropTypes = {",
            "  number: { isRequired: true }",
            "};",
            ""
          ],
          "contents": [
            "const Items = (props) => {",
            "  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>",
            "};",
            "",
            "// change code below this line",
            "",
            "// change code above this line",
            "",
            "Items.defaultProps = {",
            "  quantity: 0",
            "};",
            "",
            "class ShoppingCart extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return <Items />",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<ShoppingCart />, document.getElementById('root'))"
          ]
        }
      },
      "tests": [
        {
          "text": "应该渲染<code>ShoppingCart</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); return mockedComponent.find('ShoppingCart').length === 1; })(), '应该渲染<code>ShoppingCart</code>组件。');"
        },
        {
          "text": "应该渲染<code>Items</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ShoppingCart)); return mockedComponent.find('Items').length === 1; })(), '应该渲染<code>Items</code>组件。');"
        },
        {
          "text": "<code>Items</code>组件应该包含一个<code>propTypes</code>，以检查<code>quantity</code>是<code>number</code>类型。",
          "testString": "getUserInput => assert((function() { const noWhiteSpace = getUserInput('index').replace(/ /g, ''); return noWhiteSpace.includes('quantity:PropTypes.number.isRequired') && noWhiteSpace.includes('Items.propTypes='); })(), '<code>Items</code>组件应该包含一个<code>propTypes</code>，以检查<code>quantity</code>是<code>number</code>类型。');"
        }
      ],
      "solutions": [
        "const Items = (props) => {\n  return <h1>Current Quantity of Items in Cart: {props.quantity}</h1>\n};\n\n// change code below this line\nItems.propTypes = {\n  quantity: PropTypes.number.isRequired\n};\n// change code above this line\n\nItems.defaultProps = {\n  quantity: 0\n};\n\nclass ShoppingCart extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <Items />\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403616e",
      "title": "Access Props Using this.props",
      "releasedOn": "December 25, 2017",
      "description": [
        "前几项挑战涵盖了将 props 传递给子组件的基本方法。但是，倘若接收 prop 的子组件不是无状态函数组件，而是一个 ES6 类组件又当如何呢？ES6 类组件访问 props 的方法略有不同。",
        "任何时候，只要引用类组件本身，就要使用<code>this</code>关键字。要访问类组件中的 props，你需要在在访问它的代码前面添加<code>this</code>。例如，如果 ES6 类组件有一个名为<code>data</code>的 prop，你可以在 JSX 中这样写：<code>{this.props.data}</code>。",
        "<hr>",
        "在父组件<code>ResetPassword</code>中渲染<code>ReturnTempPassword</code>组件的一个实例。在这里，为<code>ReturnTempPassword</code>提供一个<code>tempPassword</code>prop，并赋值给 prop 一个长度至少为 8 个字符的字符串。在子组件<code>ReturnTempPassword</code>中，访问<code>strong</code>标签中的<code>tempPassword</code>prop，以确保用户看到临时密码。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class ReturnTempPassword extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "",
            "  }",
            "  render() {",
            "    return (",
            "        <div>",
            "            { /* change code below this line */ }",
            "            <p>Your temporary password is: <strong></strong></p>",
            "            { /* change code above this line */ }",
            "        </div>",
            "    );",
            "  }",
            "};",
            "",
            "class ResetPassword extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "",
            "  }",
            "  render() {",
            "    return (",
            "        <div>",
            "          <h2>Reset Password</h2>",
            "          <h3>We've generated a new temporary password for you.</h3>",
            "          <h3>Please reset this password from your account settings ASAP.</h3>",
            "          { /* change code below this line */ }",
            "",
            "          { /* change code above this line */ }",
            "        </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<ResetPassword />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>ResetPassword</code>组件应该返回单个<code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ResetPassword)); return mockedComponent.children().type() === 'div'; })(), '<code>ResetPassword</code>组件应该返回单个<code>div</code>元素。');"
        },
        {
          "text": "<code>ResetPassword</code>的第四个子组件应该是<code>ReturnTempPassword</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ResetPassword)); return mockedComponent.children().childAt(3).name() === 'ReturnTempPassword'; })(), '<code>ResetPassword</code>的第四个子组件应该是<code>ReturnTempPassword</code>组件。');"
        },
        {
          "text": "<code>ReturnTempPassword</code>组件应该有一个名为<code>tempPassword</code>的属性。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ResetPassword)); return mockedComponent.find('ReturnTempPassword').props().tempPassword; })(), '<code>ReturnTempPassword</code>组件应该有一个名为<code>tempPassword</code>的属性。');"
        },
        {
          "text": "<code>ReturnTempPassword</code>组件的<code>tempPassword</code>prop 值应该是一个字符串，其长度至少为<code>8</code>。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ResetPassword)); const temp = mockedComponent.find('ReturnTempPassword').props().tempPassword; return typeof temp === 'string' && temp.length >= 8; })(), '<code>ReturnTempPassword</code>组件的<code>tempPassword</code>prop 值应该是一个字符串，其长度至少为<code>8</code>。');"
        },
        {
          "text": "<code>ReturnTempPassword</code>组件应该显示你作为<code>tempPassword</code>prop 创建的密码，并且密码显示在<code>strong</code>标签中。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(ResetPassword)); return mockedComponent.find('strong').text() === mockedComponent.find('ReturnTempPassword').props().tempPassword; })(), '<code>ReturnTempPassword</code>组件应该显示你作为<code>tempPassword</code>prop 创建的密码，并且密码显示在<code>strong</code>标签中。');"
        }
      ],
      "solutions": [
        "class ReturnTempPassword extends React.Component {\n  constructor(props) {\n    super(props);\n\n  }\n  render() {\n    return (\n        <div>\n            <p>Your temporary password is: <strong>{this.props.tempPassword}</strong></p>\n        </div>\n    );\n  }\n};\n\nclass ResetPassword extends React.Component {\n  constructor(props) {\n    super(props);\n\n  }\n  render() {\n    return (\n        <div>\n          <h2>Reset Password</h2>\n          <h3>We've generated a new temporary password for you.</h3>\n          <h3>Please reset this password from your account settings ASAP.</h3>\n          { /* change code below this line */ }\n          <ReturnTempPassword tempPassword=\"serrPbqrPnzc\" />\n          { /* change code above this line */ }\n        </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403616f",
      "title": "Review Using Props with Stateless Functional Components",
      "releasedOn": "December 25, 2017",
      "description": [
        "除了上一个挑战，你一直在将 props 传递给无状态的函数组件。这些组件就像纯函数，它们接收 props 作为输入，并在每次传递相同 props 时返回相同的视图。你可能会想知道什么是状态，下一个挑战将会更详细地讲述它。在此之前，我们先来回顾一下组件的术语。",
        "<em>无状态函数组件</em>是一个函数，它接收 props 作为输入并返回 JSX。另一方面，<em>无状态组件</em>是一个类，它扩展了<code>React.Component</code>，但是不使用内部状态（下一个挑战中讨论）。最后，<em>状态组件</em>是指维护其自身内部状态的组件，它简称组件或 React 组件。",
        "一种常见的应用模式是尽可能减少状态组件并创建无状态的函数组件。这有助于将状态管理包含到应用程序的特定区域。反过来，通过更容易地跟踪状态变化如何影响其行为，可以改进应用程序的开发和维护。",
        "<hr>",
        "在代码编辑器中有一个<code>CampSite</code>组件，它把<code>Camper</code>组件渲染为自己的子组件。定义<code>Camper</code>组件，并为其分配默认 props<code>{ name: 'CamperBot' }</code>。你可以在<code>Camper</code>组件内部渲染任何你想要的代码，但是要确保有一个<code>p</code>元素，它只包含作为<code>prop</code>传递的<code>name</code>值。最后，在<code>Camper</code>组件上定义<code>propTypes</code>，要求提供<code>name</code>作为 prop，并验证它是<code>string</code>类型。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "head": [
            "var PropTypes = {",
            "   string: { isRequired: true }",
            "};"
          ],
          "contents": [
            "class CampSite extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <Camper/>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "// change code below this line",
            ""
          ],
          "tail": [
            "ReactDOM.render(<CampSite />, document.getElementById('root'))"
          ]
        }
      },
      "tests": [
        {
          "text": "应该渲染<code>CampSite</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(CampSite)); return mockedComponent.find('CampSite').length === 1; })(), '应该渲染<code>CampSite</code>组件。');"
        },
        {
          "text": "应该渲染<code>Camper</code>组件。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(CampSite)); return mockedComponent.find('Camper').length === 1; })(), '应该渲染<code>Camper</code>组件。');"
        },
        {
          "text": "<code>Camper</code>组件应该包含默认 props，它将字符串<code>CamperBot</code>赋值给关键字<code>name</code>。",
          "testString": "getUserInput => assert((function() { const noWhiteSpace = getUserInput('index').replace(/\\s/g, ''); const verify1 = 'Camper.defaultProps={name:\\'CamperBot\\'}'; const verify2 = 'Camper.defaultProps={name:\"CamperBot\"}'; return (noWhiteSpace.includes(verify1) || noWhiteSpace.includes(verify2)); })(), '<code>Camper</code>组件应该包含默认 props，它将字符串<code>CamperBot</code>赋值给关键字<code>name</code>。');"
        },
        {
          "text": "<code>Camper</code>组件应该包含<code>string</code>类型的<code>name</code>prop。",
          "testString": "getUserInput => assert((function() { const mockedComponent = Enzyme.mount(React.createElement(CampSite)); const noWhiteSpace = getUserInput('index').replace(/\\s/g, ''); const verifyDefaultProps = 'Camper.propTypes={name:PropTypes.string.isRequired}'; return noWhiteSpace.includes(verifyDefaultProps); })(), '<code>Camper</code>组件应该包含<code>string</code>类型的<code>name</code>prop。');"
        },
        {
          "text": "<code>Camper</code>组件应该包含一个<code>p</code>元素，元素内是来自prop<code>name</code>的唯一文本。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(CampSite)); return mockedComponent.find('p').text() === mockedComponent.find('Camper').props().name; })(), '<code>Camper</code>组件应该包含一个<code>p</code>元素，元素内是来自prop<code>name</code>的唯一文本。');"
        }
      ],
      "solutions": [
        "class CampSite extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <Camper/>\n      </div>\n    );\n  }\n};\n// change code below this line\n\nconst Camper = (props) => {\n   return (\n     <div>\n       <p>{props.name}</p>\n     </div>\n   );\n};\n\nCamper.propTypes = {\n  name: PropTypes.string.isRequired\n};\n\nCamper.defaultProps = {\n  name: 'CamperBot'\n};\n"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036170",
      "title": "Create a Stateful Component",
      "releasedOn": "December 25, 2017",
      "description": [
        "React中最重要的主题之一是<code>state</code>。 state 包含应用程序需要了解的任何数据，这些数据可能会随时间而变化。你希望应用程序能够响应 state 的变更，并在必要时显示更新后的 UI。React 为现代 Web 应用程序的状态管理提供了一个很好的解决方案。",
        "你可以通过在<code>constructor</code>中的组件类上声明<code>state</code>属性来在 React 组件中创建 state，它在创建时使用<code>state</code>初始化组件。<code>state</code>属性必须设置为 JavaScript<code>对象</code>。声明如下：",
        "<blockquote>this.state = {<br>&nbsp;&nbsp;// describe your state here<br>}</code>",
        "你可以在组件的整个生命周期内访问<code>state</code>对象，你可以更新它、在 UI 中渲染它，也可以将其作为 props 传递给子组件。<code>state</code>对象的使用可以很简单，亦可以很复杂，就看你怎么用了。请注意，你必须通过扩展<code>React.Component</code>来创建类组件，以便像这样创建<code>state</code>。",
        "<hr>",
        "代码编辑器中有一个组件试图从其<code>state</code>中渲染一个<code>name</code>属性，但是<code>state</code>还没有定义。在<code>constructor</code>中使用<code>state</code>初始化组件，并将你的名字赋给<code>name</code>属性。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "class StatefulComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    // initialize state here",
            "",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>{this.state.name}</h1>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<StatefulComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>StatefulComponent</code>应该存在并被渲染。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(StatefulComponent)); return mockedComponent.find('StatefulComponent').length === 1; })(), '<code>StatefulComponent</code>应该存在并被渲染。');"
        },
        {
          "text": "<code>StatefulComponent</code>应该渲染一个<code>div</code>元素和一个<code>h1</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(StatefulComponent)); return mockedComponent.find('div').length === 1 && mockedComponent.find('h1').length === 1; })(), '<code>StatefulComponent</code>应该渲染一个<code>div</code>元素和一个<code>h1</code>元素。');"
        },
        {
          "text": "应使用被设置为字符串的<code>name</code>属性来初始化<code>StatefulComponent</code>的 state。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(StatefulComponent)); const initialState = mockedComponent.state(); return ( typeof initialState === 'object' && typeof initialState.name === 'string'); })(), '应使用被设置为字符串的<code>name</code>属性来初始化<code>StatefulComponent</code>的 state。');"
        },
        {
          "text": "<code>StatefulComponent</code>中 state 的<code>name</code>属性应该渲染在<code>h1</code>元素里。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(StatefulComponent)); const initialState = mockedComponent.state(); return mockedComponent.find('h1').text() === initialState.name; })(), '<code>StatefulComponent</code>中 state 的<code>name</code>属性应该渲染在<code>h1</code>元素里。');"
        }
      ],
      "solutions": [
        "class StatefulComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'freeCodeCamp!'\n    }\n  }\n  render() {\n    return (\n      <div>\n        <h1>{this.state.name}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036171",
      "title": "Render State in the User Interface",
      "releasedOn": "December 25, 2017",
      "description": [
        "一旦定义了组件的初始 state，你就可以在要渲染的 UI 中显示它的任何部分。如果组件是有状态的，它将始终可以访问<code>render()</code>方法中<code>state</code>的数据。你就可以使用<code>this.state</code>访问数据。",
        "如果你想在 render 方法的<code>return</code>中访问 state 值，你必须把这个值用花括号括起来。",
        "<code>state</code>是 React 组件中最强大的特性之一，它允许你跟踪应用程序中的重要数据，并根据数据的变化渲染 UI。如果你的数据发生变化，你的 UI 也会随之改变。React 使用所谓的虚拟 DOM 来跟踪幕后的变化。当 state 数据更新时，它会使用该数据触发组件的重新渲染--包括接收 prop 数据的子组件。React 只在必要的时候更新实际的DOM，这意味着你不必担心 DOM 的变更，只需声明 UI 的外观即可。",
        "注意，如果组件有状态，则没有其他组件知道它的<code>state</code>。它的<code>state</code>是完全封装的，或者是局限于组件本身的，除非你将 state 数据作为<code>props</code>传递给子组件。封装<code>state</code>的概念非常重要，因为它允许你编写特定的逻辑，然后将该逻辑包含并隔离在代码中的某个位置。",
        "<hr>",
        "在代码编辑器中，<code>MyComponent</code>是一个有状态组件，在组件的 render 方法中定义一个<code>h1</code>标签，该方法从组件的 state 渲染<code>name</code>的值。",
        "<strong>注意：</strong>&nbsp;<code>h1</code>应该只渲染来自<code>state</code>的值。在 JSX 中，使用花括号<code>{ }</code>编写的任何代码都将被视为 JavaScript。因此，要访问<code>state</code>中的值，只需将引用括在花括号中即可。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      name: 'freeCodeCamp'",
            "    }",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code>应该有一个键<code>name</code>，其值<code>freeCodeCamp</code>存储在其 state 中。",
          "testString": "assert(Enzyme.mount(React.createElement(MyComponent)).state('name') === 'freeCodeCamp', '<code>MyComponent</code>应该有一个键<code>name</code>，其值<code>freeCodeCamp</code>存储在其 state 中。');"
        },
        {
          "text": "<code>MyComponent</code>应该在<code>div</code>中渲染一个<code>h1</code>标题。",
          "testString": "assert(/<div><h1>.*<\\/h1><\\/div>/.test(Enzyme.mount(React.createElement(MyComponent)).html()), '<code>MyComponent</code>应该在<code>div</code>中渲染一个<code>h1</code>标题。');"
        },
        {
          "text": "渲染的<code>h1</code>标题中应该包含一段文本，这段文本是从组件的 state 中渲染出来的。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ name: 'TestName' });   return waitForIt(() => mockedComponent.html()) }; const firstValue = await first(); assert(firstValue === '<div><h1>TestName</h1></div>', '渲染的<code>h1</code>标题中应该包含一段文本，这段文本是从组件的 state 中渲染出来的。');};"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'freeCodeCamp'\n    }\n  }\n  render() {\n    return (\n      <div>\n        { /* change code below this line */ }\n        <h1>{this.state.name}</h1>\n        { /* change code above this line */ }\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036172",
      "title": "Render State in the User Interface Another Way",
      "releasedOn": "December 25, 2017",
      "description": [
        "还有另一种方法可以访问组件中的<code>state</code>。在<code>render()</code>方法中，在<code>return</code>语句之前，你可以直接编写 JavaScript。例如，你可以声明函数、从<code>state</code>或<code>props</code>访问数据、对此数据执行计算等。然后，你可以将任何数据赋值给你在<code>return</code>语句中可以访问的变量。",
        "<hr>",
        "在<code>MyComponent</code>的 render 方法中，定义一个名为<code>name</code>的<code>常量</code>，并将其设置为组件<code>state</code>中的 name 值。因为可以直接在代码部分编写 JavaScript，所以不需要用大括号括起来。",
        "接下来，在 return 语句中，在<code>h1</code>标签中渲染变量<code>name</code>的值。记住，在 return 语句中需要使用 JSX 语法（用到 JavaScript 的花括号）。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      name: 'freeCodeCamp'",
            "    }",
            "  }",
            "  render() {",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "    return (",
            "      <div>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code>应该有一个键<code>name</code>，其值<code>freeCodeCamp</code>存储在其 state 中。",
          "testString": "assert(Enzyme.mount(React.createElement(MyComponent)).state('name') === 'freeCodeCamp', '<code>MyComponent</code>应该有一个键<code>name</code>，其值<code>freeCodeCamp</code>存储在其 state 中。');"
        },
        {
          "text": "<code>MyComponent</code>应该在<code>div</code>中渲染一个<code>h1</code>标题。",
          "testString": "assert(/<div><h1>.*<\\/h1><\\/div>/.test(Enzyme.mount(React.createElement(MyComponent)).html()), '<code>MyComponent</code>应该在<code>div</code>中渲染一个<code>h1</code>标题。');"
        },
        {
          "text": "渲染的<code>h1</code>标签应该包含<code>{name}</code>的引用。",
          "testString": "getUserInput => assert(/<h1>\\n*\\s*\\{\\s*name\\s*\\}\\s*\\n*<\\/h1>/.test(getUserInput('index')), '渲染的<code>h1</code>标签应该包含<code>{name}</code>的引用。');"
        },
        {
          "text": "渲染的<code>h1</code>标题中应该包含一段文本，这段文本是从组件的 state 中渲染出来的。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ name: 'TestName' });   return waitForIt(() => mockedComponent.html()) }; const firstValue = await first(); assert(firstValue === '<div><h1>TestName</h1></div>', '渲染的<code>h1</code>标题中应该包含一段文本，这段文本是从组件的 state 中渲染出来的。'); };"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'freeCodeCamp'\n    }\n  }\n  render() {\n    // change code below this line\n    const name = this.state.name;\n    // change code above this line\n    return (\n      <div>\n        { /* change code below this line */ }\n        <h1>{name}</h1>\n        { /* change code above this line */ }\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036173",
      "title": "Set State with this.setState",
      "releasedOn": "December 25, 2017",
      "description": [
        "前面的挑战涵盖了组件的<code>state</code>以及如何在<code>constructor</code>中初始化 state。还有一种方法可以更改组件的<code>state</code>，React 提供了<code>setState</code>方法来更新组件的<code>state</code>。在组件类中调用<code>setState</code>方法如下所示：<code>this.setState()</code>，传入键值对的对象，其中键是 state 属性，值是更新后的 state 数据。例如，如果我们在 state 中存储<code>username</code>，并想要更新它，代码如下所示：",
        "<blockquote>this.setState({<br>&nbsp;&nbsp;username: 'Lewis'<br>});</blockquote>",
        "React 希望你永远不要直接修改<code>state</code>，而是在 state 发生改变时始终使用<code>this.setState()</code>。此外，你应该注意，React 可以批量处理多个 state 更新以提高性能。这意味着通过<code>setState</code>方法进行的 state 更新可以是异步的。<code>setState</code>方法有一种替代语法可以解决异步问题，虽然这很少用到，但是最好还是记住它！有关详细信息，请参阅<a target=\"_blank\" href=\"https://facebook.github.io/react/docs/state-and-lifecycle.html\">React 文档</a>。",
        "<hr>",
        "代码编辑器中有一个<code>button</code>元素，它有一个<code>onClick()</code>处理程序。当<code>button</code>在浏览器中接收到单击事件时触发此处理程序，并运行<code>MyComponent</code>中定义的<code>handleClick</code>方法。在<code>handleClick</code>方法中，使用<code>this.setState()</code>更新组件的<code>state</code>。设置<code>state</code>中的<code>name</code>属性为字符串<code>React Rocks!</code>。",
        "单击按钮查看渲染的 state 的更新。如果你不完全理解单击处理程序代码在此时的工作方式，请不要担心。在接下来的挑战中会有讲述。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      name: 'Initial State'",
            "    };",
            "    this.handleClick = this.handleClick.bind(this);",
            "  }",
            "  handleClick() {",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <button onClick={this.handleClick}>Click Me</button>",
            "        <h1>{this.state.name}</h1>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code>的 state 应该使用键值对 <code>{ name: Initial State }</code> 来初始化。",
          "testString": "assert(Enzyme.mount(React.createElement(MyComponent)).state('name') === 'Initial State', '<code>MyComponent</code>的 state 应该使用键值对 <code>{ name: Initial State }</code> 来初始化。');"
        },
        {
          "text": "<code>MyComponent</code>应该渲染一个<code>h1</code>标题。",
          "testString": "assert(Enzyme.mount(React.createElement(MyComponent)).find('h1').length === 1, '<code>MyComponent</code>应该渲染一个<code>h1</code>标题。');"
        },
        {
          "text": "渲染的<code>h1</code>标题中应该包含一段文本，这段文本是从组件的 state 中渲染出来的。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ name: 'TestName' }); return waitForIt(() => mockedComponent.html()); }; const firstValue = await first(); assert(/<h1>TestName<\\/h1>/.test(firstValue), '渲染的<code>h1</code>标题中应该包含一段文本，这段文本是从组件的 state 中渲染出来的。'); };"
        },
        {
          "text": "调用<code>MyComponent</code>的<code>handleClick</code>方法应该将 state 的 name 属性设置为<code>React Rocks!</code>。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ name: 'Before' }); return waitForIt(() => mockedComponent.state('name')); }; const second = () => { mockedComponent.instance().handleClick(); return waitForIt(() => mockedComponent.state('name')); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === 'Before' && secondValue === 'React Rocks!', '调用<code>MyComponent</code>的<code>handleClick</code>方法应该将 state 的 name 属性设置为<code>React Rocks!</code>。'); };"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'Initial State'\n    };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n     // change code below this line\n    this.setState({\n      name: 'React Rocks!'\n    });\n    // change code above this line\n  }\n  render() {\n    return (\n      <div>\n        <button onClick = {this.handleClick}>Click Me</button>\n        <h1>{this.state.name}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036174",
      "title": "Bind 'this' to a Class Method",
      "releasedOn": "December 25, 2017",
      "description": [
        "除了设置和更新<code>state</code>之外，你还可以为组件类定义方法。类方法通常需要使用<code>this</code>关键字，以便它可以访问方法中类的属性（例如<code>state</code>和<code>props </code>）。有几种方法可以让你的类方法访问<code>this</code>。",
        "一种常见的方法是在构造函数中显式地绑定<code>this</code>，这样当组件初始化时，<code>this</code>就会绑定到类方法。你可能已经注意到上一个挑战使用了<code>this.handleClick = this.handleClick.bind(this)</code>用于其在构造函数中的<code>handleClick</code>方法。然后，当你在类方法中调用像<code>this.setState()</code>这样的函数时，<code>this</code>指的是这个类，而不是<code>undefined</code>。",
        "<strong>注意：</strong>&nbsp;<code>this</code>关键字是 JavaScript 中最令人困惑的方面之一，但它在 React 中扮演着重要的角色。虽然它的行为在这里是完全正常的，但是这些课程并不深入研究<code>this</code>，所以如果以上内容令你感到困惑，请参考其他课程！",
        "<hr>",
        "代码编辑器有一个带有<code>state</code>的组件，用于跟踪项目计数。它还有一个方法，允许你增加此项目计数。但是，该方法不起作用，因为它使用了未定义的<code>this</code>关键字。可以通过将<code>this</code>显式绑定到组件构造函数中的<code>addItem()</code>方法来修复它。",
        "接下来，向 render 方法中的<code>button</code>元素添加一个单击处理程序。当按钮接收到单击事件时，它应该触发<code>addItem()</code>方法。记住，传递给<code>onClick</code>处理程序的方法需要使用花括号，因为它应该直接被解释为 JavaScript。",
        "完成上述步骤后，你应该可以单击按钮并查看 HTML 中的项目计数增量。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      itemCount: 0",
            "    };",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  addItem() {",
            "    this.setState({",
            "      itemCount: this.state.itemCount + 1",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        { /* change code below this line */ }",
            "        <button>Click Me</button>",
            "        { /* change code above this line */ }",
            "        <h1>Current Item Count: {this.state.itemCount}</h1>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code>应返回<code>div</code>元素，该元素按顺序包含两个元素，一个按钮和一个<code>h1</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(MyComponent)).find('div').length === 1 && Enzyme.mount(React.createElement(MyComponent)).find('div').childAt(0).type() === 'button' && Enzyme.mount(React.createElement(MyComponent)).find('div').childAt(1).type() === 'h1', '<code>MyComponent</code>应返回<code>div</code>元素，该元素按顺序包含两个元素，一个按钮和一个<code>h1</code>元素。');"
        },
        {
          "text": "<code>MyComponent</code>的 state 应该使用键值对<code>{ itemCount: 0 }</code>进行初始化。",
          "testString": "assert(Enzyme.mount(React.createElement(MyComponent)).state('itemCount') === 0, '<code>MyComponent</code>的 state 应该使用键值对<code>{ itemCount: 0 }</code>进行初始化。');"
        },
        {
          "text": "单击<code>button</code>元素应该运行<code>addItem</code>方法，并使 state<code>itemCount</code>的计数增加<code>1</code>。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ itemCount: 0 }); return waitForIt(() => mockedComponent.state('itemCount')); }; const second = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent.state('itemCount')); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === 0 && secondValue === 1, '单击<code>button</code>元素应该运行<code>addItem</code>方法，并使 state<code>itemCount</code>的计数增加<code>1</code>。'); };"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      itemCount: 0\n    };\n    this.addItem = this.addItem.bind(this);\n  }\n  addItem() {\n    this.setState({\n      itemCount: this.state.itemCount + 1\n    });\n  }\n  render() {\n    return (\n      <div>\n        <button onClick = {this.addItem}>Click Me</button>\n        <h1>Current Item Count: {this.state.itemCount}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036176",
      "title": "Use State to Toggle an Element",
      "releasedOn": "December 25, 2017",
      "description": [
        "你可以用比你目前所见的更复杂的方式在 React 应用程序中使用<code>state</code>。例如，监视值的状态，然后根据此值有条件地渲染 UI。有几种不同的方法可以实现这一点，代码编辑器展示了其中一种。",
        "<hr>",
        "<code>MyComponent</code>有一个初始值为<code>false</code>的<code>visibility</code>属性。如果<code>visibility</code>的值为 true，render 方法返回一个视图，如果为 false，返回另一个视图。",
        "目前，无法更新组件的<code>state</code>中的<code>visibility</code>属性，该值应在 true 和 false 之间来回切换。按钮上有一个单击处理程序，它触发一个名为<code>toggleVisibility()</code>的类方法。定义此方法，以便<code>visibility</code>的<code>state</code>在调用方法时切换到相反的值。如果<code>visibility</code>是<code>false</code>，则该方法将其设置为<code>true</code>，反之亦然。",
        "最后，单击按钮以查看基于其<code>state</code>的组件的条件渲染。",
        "<strong>提示：</strong>&nbsp;不要忘记将<code>this</code>关键字绑定到构造函数中的方法上！"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      visibility: false",
            "    };",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "  render() {",
            "    if (this.state.visibility) {",
            "      return (",
            "        <div>",
            "          <button onClick={this.toggleVisibility}>Click Me</button>",
            "          <h1>Now you see me!</h1>",
            "        </div>",
            "      );",
            "    } else {",
            "      return (",
            "        <div>",
            "          <button onClick={this.toggleVisibility}>Click Me</button>",
            "        </div>",
            "      );",
            "    }",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code>应该返回一个<code>div</code>元素，其中包含一个<code>button</code>元素。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(MyComponent)).find('div').find('button').length, 1, '<code>MyComponent</code>应该返回一个<code>div</code>元素，其中包含一个<code>button</code>元素。');"
        },
        {
          "text": "<code>MyComponent</code>应该使用设置为<code>false</code>的<code>visibility</code>属性来初始化其 state。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(MyComponent)).state('visibility'), false, '<code>MyComponent</code>应该使用设置为<code>false</code>的<code>visibility</code>属性来初始化其 state。');"
        },
        {
          "text": "单击按钮元素应在<code>true</code>和<code>false</code>之间切换<code>visibility</code>属性的状态。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ visibility: false }); return waitForIt(() => mockedComponent.state('visibility')); }; const second = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent.state('visibility')); }; const third = () => { mockedComponent.find('button').simulate('click'); return waitForIt(() => mockedComponent.state('visibility')); }; const firstValue = await first(); const secondValue = await second(); const thirdValue = await third(); assert(!firstValue && secondValue && !thirdValue, '单击按钮元素应在<code>true</code>和<code>false</code>之间切换<code>visibility</code>属性的状态。'); }; "
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      visibility: false\n    };\n    this.toggleVisibility = this.toggleVisibility.bind(this);\n   }\n  toggleVisibility() {\n    this.setState({\n      visibility: !this.state.visibility\n    });\n  }\n  render() {\n    if (this.state.visibility) {\n      return (\n        <div>\n          <button onClick = {this.toggleVisibility}>Click Me</button>\n          <h1>Now you see me!</h1>\n        </div>\n      );\n    } else {\n      return (\n        <div>\n          <button onClick = {this.toggleVisibility}>Click Me</button>\n        </div>\n      );\n    }\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036177",
      "title": "Write a Simple Counter",
      "releasedOn": "December 25, 2017",
      "description": [
        "你可以结合目前为止所涵盖的概念来设计更复杂的有状态组件。这包括初始化<code>state</code>，编写设置<code>state</code>的方法，以及指定单击处理程序来触发这些方法。",
        "<hr>",
        "<code>Counter</code>组件跟踪<code>state</code>中的<code>count</code>值。有两个按钮分别调用<code>increment()</code>和<code>decrement()</code>方法。编写这些方法，使计数器值在单击相应按钮时增加或减少 1。另外，创建一个<code>reset()</code>方法，当单击 reset 按钮时，把计数设置为 0。",
        "<strong>注意：</strong>&nbsp;确保你没有修改按钮的<code>classNames</code>。另外，请记住在构造函数中为新创建的方法添加必要的绑定。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class Counter extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      count: 0",
            "    };",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "  render() {",
            "    return (",
            "      <div>",
            "        <button className='inc' onClick={this.increment}>Increment!</button>",
            "        <button className='dec' onClick={this.decrement}>Decrement!</button>",
            "        <button className='reset' onClick={this.reset}>Reset</button>",
            "        <h1>Current Count: {this.state.count}</h1>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<Counter />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>Counter</code>应该返回一个<code>div</code>元素，它包含三个按钮，按钮内容依次是<code>Increment!</code>、<code>Decrement!</code>、<code>Reset</code>。",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(Counter)); return (mockedComponent.find('.inc').text() === 'Increment!' && mockedComponent.find('.dec').text() === 'Decrement!' && mockedComponent.find('.reset').text() === 'Reset'); })(), '<code>Counter</code>应该返回一个<code>div</code>元素，它包含三个按钮，按钮内容依次是<code>Increment!</code>、<code>Decrement!</code>、<code>Reset</code>。');"
        },
        {
          "text": "<code>Counter</code>应该使用设置为<code>0</code>的<code>count</code>属性初始化 state。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(Counter)).state('count'), 0, '<code>Counter</code>应该使用设置为<code>0</code>的<code>count</code>属性初始化 state。');"
        },
        {
          "text": "单击 increment 按钮应将计数增加<code>1</code>。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(Counter)); const first = () => { mockedComponent.setState({ count: 0 }); return waitForIt(() => mockedComponent.state('count')); }; const second = () => { mockedComponent.find('.inc').simulate('click'); return waitForIt(() => mockedComponent.state('count')); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === 0 && secondValue === 1, '单击 increment 按钮应将计数增加<code>1</code>。'); }; "
        },
        {
          "text": "单击 decrement 按钮应将计数减少<code>1</code>。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(Counter)); const first = () => { mockedComponent.setState({ count: 0 }); return waitForIt(() => mockedComponent.state('count')); }; const second = () => { mockedComponent.find('.dec').simulate('click'); return waitForIt(() => mockedComponent.state('count')); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === 0 && secondValue === -1, '单击 decrement 按钮应将计数减少<code>1</code>。'); }; "
        },
        {
          "text": "单击 reset 按钮应将计数重置为<code>0</code>。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(Counter)); const init = () => { mockedComponent.setState({ count: 0 }); return waitForIt(() => mockedComponent.state('count')); }; const increment = () => { mockedComponent.find('.inc').simulate('click'); mockedComponent.find('.inc').simulate('click'); return waitForIt(() => mockedComponent.state('count')); }; const decrement = () => { mockedComponent.find('.dec').simulate('click'); return waitForIt(() => mockedComponent.state('count')); }; const reset = () => { mockedComponent.find('.reset').simulate('click'); return waitForIt(() => mockedComponent.state('count')); }; const firstValue = await init(); const secondValue = await increment(); const thirdValue = await decrement(); const fourthValue = await reset(); assert(firstValue === 0 && secondValue === 2 && thirdValue === 1 && fourthValue === 0, '单击 reset 按钮应将计数重置为<code>0</code>。'); }; "
        }
      ],
      "solutions": [
        "class Counter extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      count: 0\n    };\n  this.increment = this.increment.bind(this);\n this.decrement = this.decrement.bind(this);\n this.reset = this.reset.bind(this);\n }\n  reset() {\n    this.setState({\n      count: 0\n    });\n  }\n  increment() {\n    this.setState({\n      count: this.state.count + 1\n    });\n  }\n  decrement() {\n    this.setState({\n      count: this.state.count - 1\n    });\n  }\n  render() {\n    return (\n      <div>\n        <button className='inc' onClick={this.increment}>Increment!</button>\n        <button className='dec' onClick={this.decrement}>Decrement!</button>\n        <button className='reset' onClick={this.reset}>Reset</button>\n        <h1>Current Count: {this.state.count}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036178",
      "title": "Create a Controlled Input",
      "releasedOn": "December 25, 2017",
      "description": [
        "您的应用程序可能在<code>state</code>和渲染的 UI 之间有更复杂的交互。例如，用于文本输入的表单控件元素（如<code>input</code>和<code>textarea</code>）在用户键入时在 DOM 中维护自己的 state。通过 React，您可以将这种可变 state 转移到 React 组件的<code>state</code>中。用户的输入变成了应用程序<code>state</code>的一部分，因此 React 控制该输入字段的值。通常，如果您的 React 组件具有用户可以键入的输入字段，那么它将是一个受控的输入表单。",
        "<hr>",
        "代码编辑器具有一个名为<code>ControlledInput</code>的组件框架，用于创建受控的<code>input</code>元素。组件的<code>state</code>已经被包含空字符串的<code>input</code>属性初始化。此值表示用户在<code>input</code>字段中键入的文本。",
        "首先，创建一个名为<code>handleChange()</code>的方法，该方法具有一个名为<code>event</code>的参数。方法被调用时，它接收一个<code>event</code>对象，该对象包含一个来自<code>input</code>元素的字符串文本。您可以使用方法内的<code>event.target.value</code>来访问这个字符串。用这个新字符串更新组件的<code>state</code>的<code>input</code>属性。",
        "在 render 方法中，在<code>h4</code>标签之上创建<code>input</code>元素。添加一个<code>value</code>属性，它等于组件的<code>state</code>的<code>input</code>属性。然后将<code>onChange()</code>事件处理程序设置到<code>handleChange()</code>方法。",
        "在输入框中键入时，该文本由<code>handleChange()</code>方法处理，该文本被设置为本地<code>state</code>中的<code>input</code>属性，并渲染在页面上的<code>input</code>框中。组件<code>state</code>是输入数据的唯一真实来源。",
        "最后也是最重要的，不要忘记在构造函数中添加必要的绑定。"
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class ControlledInput extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: ''",
            "    };",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "  render() {",
            "    return (",
            "      <div>",
            "        { /* change code below this line */}",
            "",
            "        { /* change code above this line */}",
            "        <h4>Controlled Input:</h4>",
            "        <p>{this.state.input}</p>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<ControlledInput />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>ControlledInput</code>应该返回包含一个<code>input</code>标签和<code>p</code>标签的<code>div</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(ControlledInput)).find('div').children().find('input').length === 1 && Enzyme.mount(React.createElement(ControlledInput)).find('div').children().find('p').length === 1, '<code>ControlledInput</code>应该返回包含一个<code>input</code>标签和<code>p</code>标签的<code>div</code>元素。');"
        },
        {
          "text": "<code>ControlledInput</code>的 state 应该使用设置为空字符串的<code>input</code>属性初始化。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(ControlledInput)).state('input'), '', '<code>ControlledInput</code>的 state 应该使用设置为空字符串的<code>input</code>属性初始化。');"
        },
        {
          "text": "input 元素中的键入值应该更新 input 的 state 和值，并且<code>p</code>元素应该在输入时呈现 state。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(ControlledInput)); const _1 = () => { mockedComponent.setState({ input: '' }); return waitForIt(() => mockedComponent.state('input'))}; const _2 = () => { mockedComponent.find('input').simulate('change', { target: { value: 'TestInput' }}); return waitForIt(() => ({ state: mockedComponent.state('input'), text: mockedComponent.find('p').text(), inputVal: mockedComponent.find('input').props().value }))}; const before = await _1(); const after = await _2(); assert(before === '' && after.state === 'TestInput' && after.text === 'TestInput' && after.inputVal === 'TestInput', 'input 元素中的键入值应该更新 input 的 state 和值，并且<code>p</code>元素应该在输入时呈现 state。'); }; "
        }
      ],
      "solutions": [
        "class ControlledInput extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: ''\n    };\n    this.handleChange = this.handleChange.bind(this);\n  }\n  handleChange(event) {\n    this.setState({\n      input: event.target.value\n    });\n  }\n  render() {\n    return (\n      <div>\n        <input\n          value={this.state.input}\n          onChange={this.handleChange} />\n        <h4>Controlled Input:</h4>\n\n        <p>{this.state.input}</p>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036179",
      "title": "Create a Controlled Form",
      "releasedOn": "December 25, 2017",
      "description": [
        "The last challenge showed that React can control the internal state for certain elements like <code>input</code> and <code>textarea</code>, which makes them controlled components. This applies to other form elements as well, including the regular HTML <code>form</code>元素。",
        "<hr>",
        "The <code>MyForm</code> component is set up with an empty <code>form</code> with a submit handler. The submit handler will be called when the form is submitted.",
        "We've added a button which submits the form. You can see it has the <code>type</code> set to <code>submit</code> indicating it is the button controlling the form. Add the <code>input</code> element in the <code>form</code> and set its <code>value</code> and <code>onChange()</code> attributes like the last challenge. You should then complete the <code>handleSubmit</code> method so that it sets the component state property <code>submit</code> to the current input value in the local <code>state</code>.",
        "<strong>Note:</strong>&nbsp; You also must call <code>event.preventDefault()</code> in the submit handler, to prevent the default form submit behavior which will refresh the web page.",
        "Finally, create an <code>h1</code> tag after the <code>form</code> which renders the <code>submit</code> value from the component's <code>state</code>. You can then type in the form and click the button (or press enter), and you should see your input rendered to the page."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyForm extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: '',",
            "      submit: ''",
            "    };",
            "    this.handleChange = this.handleChange.bind(this);",
            "    this.handleSubmit = this.handleSubmit.bind(this);",
            "  }",
            "  handleChange(event) {",
            "    this.setState({",
            "      input: event.target.value",
            "    });",
            "  }",
            "  handleSubmit(event) {",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <form onSubmit={this.handleSubmit}>",
            "          { /* change code below this line */ }",
            "",
            "          { /* change code above this line */ }",
            "          <button type='submit'>Submit!</button>",
            "        </form>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyForm />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyForm</code> should return a <code>div</code> element which contains a <code>form</code> and an <code>h1</code> tag. The form should include an <code>input</code> and a <code>button</code>.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(MyForm)); return (mockedComponent.find('div').children().find('form').length === 1 && mockedComponent.find('div').children().find('h1').length === 1 && mockedComponent.find('form').children().find('input').length === 1 && mockedComponent.find('form').children().find('button').length === 1) })(), '<code>MyForm</code> should return a <code>div</code> element which contains a <code>form</code> and an <code>h1</code> tag. The form should include an <code>input</code> and a <code>button</code>.');"
        },
        {
          "text": "The state of <code>MyForm</code> should initialize with <code>input</code> and <code>submit</code> properties, both set to empty strings.",
          "testString": "assert(Enzyme.mount(React.createElement(MyForm)).state('input') === '' && Enzyme.mount(React.createElement(MyForm)).state('submit') === '', 'The state of <code>MyForm</code> should initialize with <code>input</code> and <code>submit</code> properties, both set to empty strings.');"
        },
        {
          "text": "Typing in the <code>input</code> element should update the <code>input</code> property of the component&apos;s state.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyForm)); const _1 = () => { mockedComponent.setState({ input: '' }); return waitForIt(() => mockedComponent.state('input'))}; const _2 = () => { mockedComponent.find('input').simulate('change', { target: { value: 'TestInput' }}); return waitForIt(() => ({ state: mockedComponent.state('input'), inputVal: mockedComponent.find('input').props().value }))}; const before = await _1(); const after = await _2(); assert(before === '' && after.state === 'TestInput' && after.inputVal === 'TestInput', 'Typing in the <code>input</code> element should update the <code>input</code> property of the component&apos;s state.'); }; "
        },
        {
          "text": "Submitting the form should run <code>handleSubmit</code> which should set the <code>submit</code> property in state equal to the current input.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyForm)); const _1 = () => { mockedComponent.setState({ input: '' }); mockedComponent.setState({submit: ''}); mockedComponent.find('input').simulate('change', {target: {value: 'SubmitInput'}}); return waitForIt(() => mockedComponent.state('submit'))}; const _2 = () => { mockedComponent.find('form').simulate('submit'); return waitForIt(() => mockedComponent.state('submit'))}; const before = await _1(); const after = await _2(); assert(before === '' && after === 'SubmitInput', 'Submitting the form should run <code>handleSubmit</code> which should set the <code>submit</code> property in state equal to the current input.'); };"
        },
        {
          "text": "The <code>h1</code> header should render the value of the <code>submit</code> field from the component&apos;s state.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyForm)); const _1 = () => { mockedComponent.setState({ input: '' }); mockedComponent.setState({submit: ''}); mockedComponent.find('input').simulate('change', {target: {value: 'TestInput'}}); return waitForIt(() => mockedComponent.find('h1').text())}; const _2 = () => { mockedComponent.find('form').simulate('submit'); return waitForIt(() => mockedComponent.find('h1').text())}; const before = await _1(); const after = await _2(); assert(before === '' && after === 'TestInput', 'The <code>h1</code> header should render the value of the <code>submit</code> field from the component&apos;s state.'); }; "
        }
      ],
      "solutions": [
        "class MyForm extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: '',\n      submit: ''\n    };\n    this.handleChange = this.handleChange.bind(this);\n    this.handleSubmit = this.handleSubmit.bind(this);\n  }\n  handleChange(event) {\n    this.setState({\n      input: event.target.value\n    });\n  }\n  handleSubmit(event) {\n    event.preventDefault()\n    this.setState({\n      submit: this.state.input\n    });\n  }\n  render() {\n    return (\n      <div>\n        <form onSubmit={this.handleSubmit}>\n          <input\n            value={this.state.input}\n            onChange={this.handleChange} />\n          <button type='submit'>Submit!</button>\n        </form>\n        <h1>{this.state.submit}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403617a",
      "title": "Pass State as Props to Child Components",
      "releasedOn": "December 25, 2017",
      "description": [
        "You saw a lot of examples that passed props to child JSX elements and child React components in previous challenges. You may be wondering where those props come from. A common pattern is to have a stateful component containing the <code>state</code> important to your app, that then renders child components. You want these components to have access to some pieces of that <code>state</code>, which are passed in as props.",
        "For example, maybe you have an <code>App</code> component that renders a <code>Navbar</code>, among other components. In your <code>App</code>, you have <code>state</code> that contains a lot of user information, but the <code>Navbar</code> only needs access to the user's username so it can display it. You pass that piece of <code>state</code> to the <code>Navbar</code> component as a prop.",
        "This pattern illustrates some important paradigms in React. The first is <em>unidirectional data flow</em>. State flows in one direction down the tree of your application's components, from the stateful parent component to child components. The child components only receive the state data they need. The second is that complex stateful apps can be broken down into just a few, or maybe a single, stateful组件。 The rest of your components simply receive state from the parent as props, and render a UI from that state. It begins to create a separation where state management is handled in one part of code and UI rendering in another. This principle of separating state logic from UI logic is one of React's key principles. When it's used correctly, it makes the design of complex, stateful applications much easier to manage.",
        "<hr>",
        "The <code>MyApp</code> component is stateful and renders a <code>Navbar</code> component as a child. Pass the <code>name</code> property in its <code>state</code> down to the child component, then show the <code>name</code> in the <code>h1</code> tag that's part of the <code>Navbar</code> render method."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyApp extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      name: 'CamperBot'",
            "    }",
            "  }",
            "  render() {",
            "    return (",
            "       <div>",
            "         <Navbar /* your code here */ />",
            "       </div>",
            "    );",
            "  }",
            "};",
            "",
            "class Navbar extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "    <div>",
            "      <h1>Hello, my name is: /* your code here */ </h1>",
            "    </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyApp />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>MyApp</code> component should render with a <code>Navbar</code> component inside.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyApp)); return mockedComponent.find('MyApp').length === 1 && mockedComponent.find('Navbar').length === 1; })(), 'The <code>MyApp</code> component should render with a <code>Navbar</code> component inside.');"
        },
        {
          "text": "The <code>Navbar</code> component should receive the <code>MyApp</code> state property <code>name</code> as props.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyApp)); const setState = () => { mockedComponent.setState({name: 'TestName'}); return waitForIt(() => mockedComponent.find('Navbar').props() )}; const navProps = await setState(); assert(navProps.name === 'TestName', 'The <code>Navbar</code> component should receive the <code>MyApp</code> state property <code>name</code> as props.'); }; "
        },
        {
          "text": "The <code>h1</code> element in <code>Navbar</code> should render the <code>name</code> prop.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyApp)); const navH1Before = mockedComponent.find('Navbar').find('h1').text(); const setState = () => { mockedComponent.setState({name: 'TestName'}); return waitForIt(() => mockedComponent.find('Navbar').find('h1').text() )}; const navH1After = await setState(); assert(new RegExp('TestName').test(navH1After) && navH1After !== navH1Before, 'The <code>h1</code> element in <code>Navbar</code> should render the <code>name</code> prop.'); }; "
        }
      ],
      "solutions": [
        "class MyApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      name: 'CamperBot'\n    }\n  }\n  render() {\n    return (\n       <div>\n         <Navbar name={this.state.name}/>\n       </div>\n    );\n  }\n};\nclass Navbar extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n    <div>\n      <h1>Hello, my name is: {this.props.name}</h1>\n    </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403617b",
      "title": "Pass a Callback as Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "You can pass <code>state</code> as props to child components, but you're not limited to passing data. You can also pass handler functions or any method that's defined on a React component to a child组件。 This is how you allow child components to interact with their parent components. You pass methods to a child just like a regular prop. It's assigned a name and you have access to that method name under <code>this.props</code> in the child组件。",
        "<hr>",
        "There are three components outlined in the code editor. The <code>MyApp</code> component is the parent that will render the <code>GetInput</code> and <code>RenderInput</code> child components. Add the <code>GetInput</code> component to the render method in <code>MyApp</code>, then pass it a prop called <code>input</code> assigned to <code>inputValue</code> from <code>MyApp</code>&apos;s <code>state</code>. Also create a prop called <code>handleChange</code> and pass the input handler <code>handleChange</code> to it.",
        "Next, add <code>RenderInput</code> to the render method in <code>MyApp</code>, then create a prop called <code>input</code> and pass the <code>inputValue</code> from <code>state</code> to it. Once you are finished you will be able to type in the <code>input</code> field in the <code>GetInput</code> component, which then calls the handler method in its parent via props. This updates the input in the <code>state</code> of the parent, which is passed as props to both children. Observe how the data flows between the components and how the single source of truth remains the <code>state</code> of the parent组件。 Admittedly, this example is a bit contrived, but should serve to illustrate how data and callbacks can be passed between React components."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyApp extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      inputValue: ''",
            "    }",
            "    this.handleChange = this.handleChange.bind(this);",
            "  }",
            "  handleChange(event) {",
            "    this.setState({",
            "      inputValue: event.target.value",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "       <div>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "       </div>",
            "    );",
            "  }",
            "};",
            "",
            "class GetInput extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h3>Get Input:</h3>",
            "        <input",
            "          value={this.props.input}",
            "          onChange={this.props.handleChange}/>",
            "      </div>",
            "    );",
            "  }",
            "};",
            "",
            "class RenderInput extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h3>Input Render:</h3>",
            "        <p>{this.props.input}</p>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyApp />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>MyApp</code> component should render.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyApp)); return mockedComponent.find('MyApp').length === 1; })(), 'The <code>MyApp</code> component should render.');"
        },
        {
          "text": "The <code>GetInput</code> component should render.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyApp)); return mockedComponent.find('GetInput').length === 1; })(), 'The <code>GetInput</code> component should render.');"
        },
        {
          "text": "The <code>RenderInput</code> component should render.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyApp)); return mockedComponent.find('RenderInput').length === 1; })(), 'The <code>RenderInput</code> component should render.');"
        },
        {
          "text": "The <code>GetInput</code> component should receive the <code>MyApp</code> state property <code>inputValue</code> as props and contain an <code>input</code> element which modifies <code>MyApp</code> state.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyApp)); const state_1 = () => { mockedComponent.setState({inputValue: ''}); return waitForIt(() => mockedComponent.state() )}; const state_2 = () => { mockedComponent.find('input').simulate('change', {target: {value: 'TestInput'}}); return waitForIt(() => mockedComponent.state() )}; const updated_1 = await state_1(); const updated_2 = await state_2(); assert(updated_1.inputValue === '' && updated_2.inputValue === 'TestInput', 'The <code>GetInput</code> component should receive the <code>MyApp</code> state property <code>inputValue</code> as props and contain an <code>input</code> element which modifies <code>MyApp</code> state.'); }; "
        },
        {
          "text": "The <code>RenderInput</code> component should receive the <code>MyApp</code> state property <code>inputValue</code> as props.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyApp)); const state_1 = () => { mockedComponent.setState({inputValue: 'TestName'}); return waitForIt(() => mockedComponent )}; const updated_1 = await state_1(); assert(updated_1.find('p').text().includes('TestName'), 'The <code>RenderInput</code> component should receive the <code>MyApp</code> state property <code>inputValue</code> as props.'); }; "
        }
      ],
      "solutions": [
        "class MyApp extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      inputValue: ''\n    }\n  this.handleChange = this.handleChange.bind(this);  \n  }\n  handleChange(event) {\n    this.setState({\n      inputValue: event.target.value\n    });\n  }\n  render() {\n    return (\n       <div>\n         <GetInput\n           input={this.state.inputValue}\n           handleChange={this.handleChange}/>\n         <RenderInput\n           input={this.state.inputValue}/>\n       </div>\n    );\n  }\n};\n\nclass GetInput extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h3>Get Input:</h3>\n        <input\n          value={this.props.input}\n          onChange={this.props.handleChange}/>\n      </div>\n    );\n  }\n};\n\nclass RenderInput extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <div>\n        <h3>Input Render:</h3>\n        <p>{this.props.input}</p>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403617c",
      "title": "Use the Lifecycle Method componentWillMount",
      "releasedOn": "December 25, 2017",
      "description": [
        "React components have several special methods that provide opportunities to perform actions at specific points in the lifecycle of a组件。 These are called lifecycle methods, or lifecycle hooks, and allow you to catch components at certain points in time. This can be before they are rendered, before they update, before they receive props, before they unmount, and so on. Here is a list of some of the main lifecycle methods:",
        "<code>componentWillMount()</code>",
        "<code>componentDidMount()</code>",
        "<code>componentWillReceiveProps()</code>",
        "<code>shouldComponentUpdate()</code>",
        "<code>componentWillUpdate()</code>",
        "<code>componentDidUpdate()</code>",
        "<code>componentWillUnmount()</code>",
        "The next several lessons will cover some of the basic use cases for these lifecycle methods.",
        "<hr>",
        "The <code>componentWillMount()</code> method is called before the <code>render()</code> method when a component is being mounted to the DOM. Log something to the console within <code>componentWillMount()</code> - you may want to have your browser console open to see the output."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  componentWillMount() {",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "  }",
            "  render() {",
            "    return <div />",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code> should render a <code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.find('div').length === 1; })(), '<code>MyComponent</code> should render a <code>div</code>元素。');"
        },
        {
          "text": "<code>console.log</code> should be called in <code>componentWillMount</code>.",
          "testString": "assert((function() { const lifecycle = React.createElement(MyComponent).type.prototype.componentWillMount.toString().replace(/ /g,''); return lifecycle.includes('console.log('); })(), '<code>console.log</code> should be called in <code>componentWillMount</code>.');"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  componentWillMount() {\n    // change code below this line\n    console.log('Component is mounting...');\n    // change code above this line\n  }\n  render() {\n    return <div />\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403617d",
      "title": "Use the Lifecycle Method componentDidMount",
      "releasedOn": "December 25, 2017",
      "description": [
        "Most web developers, at some point, need to call an API endpoint to retrieve data. If you're working with React, it's important to know where to perform this action.",
        "The best practice with React is to place API calls or any calls to your server in the lifecycle method <code>componentDidMount()</code>. This method is called after a component is mounted to the DOM. Any calls to <code>setState()</code> here will trigger a re-rendering of your组件。 When you call an API in this method, and set your state with the data that the API returns, it will automatically trigger an update once you receive the data.",
        "<hr>",
        "There is a mock API call in <code>componentDidMount()</code>. It sets state after 2.5 seconds to simulate calling a server to retrieve data. This example requests the current total active users for a site. In the render method, render the value of <code>activeUsers</code> in the <code>h1</code>. Watch what happens in the preview, and feel free to change the timeout to see the different effects."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      activeUsers: null",
            "    };",
            "  }",
            "  componentDidMount() {",
            "    setTimeout( () => {",
            "      this.setState({",
            "        activeUsers: 1273",
            "      });",
            "    }, 2500);",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>Active Users: { /* change code here */ }</h1>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code> should render a <code>div</code> element which wraps an <code>h1</code> tag.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return (mockedComponent.find('div').length === 1 && mockedComponent.find('h1').length === 1); })(), '<code>MyComponent</code> should render a <code>div</code> element which wraps an <code>h1</code> tag.');"
        },
        {
          "text": "Component state should be updated with a timeout function in <code>componentDidMount</code>.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return new RegExp('setTimeout(.|\\n)+setState(.|\\n)+activeUsers').test(String(mockedComponent.instance().componentDidMount)); })(), 'Component state should be updated with a timeout function in <code>componentDidMount</code>.');"
        },
        {
          "text": "The <code>h1</code> tag should render the <code>activeUsers</code> value from <code>MyComponent</code>&apos;s state.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const first = () => { mockedComponent.setState({ activeUsers: 1237 }); return waitForIt(() => mockedComponent.find('h1').text()); }; const second = () => { mockedComponent.setState({ activeUsers: 1000 }); return waitForIt(() => mockedComponent.find('h1').text()); }; const firstValue = await first(); const secondValue = await second(); assert(new RegExp('1237').test(firstValue) && new RegExp('1000').test(secondValue), 'The <code>h1</code> tag should render the <code>activeUsers</code> value from <code>MyComponent</code>&apos;s state.'); }; "
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      activeUsers: null\n    };\n  }\n  componentDidMount() {\n    setTimeout( () => {\n      this.setState({\n        activeUsers: 1273\n      });\n    }, 2500);\n  }\n  render() {\n    return (\n      <div>\n        <h1>Active Users: {this.state.activeUsers}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403617e",
      "title": "Add Event Listeners",
      "releasedOn": "December 25, 2017",
      "description": [
        "The <code>componentDidMount()</code> method is also the best place to attach any event listeners you need to add for specific functionality. React provides a synthetic event system which wraps the native event system present in browsers. This means that the synthetic event system behaves exactly the same regardless of the user's browser - even if the native events may behave differently between different browsers.",
        "You've already been using some of these synthetic event handlers such as <code>onClick()</code>. React's synthetic event system is great to use for most interactions you'll manage on DOM elements. However, if you want to attach an event handler to the document or window objects, you have to do this directly.",
        "<hr>",
        "Attach an event listener in the <code>componentDidMount()</code> method for <code>keydown</code> events and have these events trigger the callback <code>handleKeyPress()</code>. You can use <code>document.addEventListener()</code> which takes the event (in quotes) as the first argument and the callback as the second argument.",
        "Then, in <code>componentWillUnmount()</code>, remove this same event listener. You can pass the same arguments to <code>document.removeEventListener()</code>. It's good practice to use this lifecycle method to do any clean up on React components before they are unmounted and destroyed. Removing event listeners is an example of one such clean up action."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      message: ''",
            "    };",
            "    this.handleEnter = this.handleEnter.bind(this);",
            "    this.handleKeyPress = this.handleKeyPress.bind(this);",
            "  }",
            "  // change code below this line",
            "  componentDidMount() {",
            "",
            "  }",
            "  componentWillUnmount() {",
            "",
            "  }",
            "  // change code above this line",
            "  handleEnter() {",
            "    this.setState({",
            "      message: this.state.message + 'You pressed the enter key! '",
            "    });",
            "  }",
            "  handleKeyPress(event) {",
            "    if (event.keyCode === 13) {",
            "      this.handleEnter();",
            "    }",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <h1>{this.state.message}</h1>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code> should render a <code>div</code> element which wraps an <code>h1</code> tag.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.find('div').children().find('h1').length === 1; })(), '<code>MyComponent</code> should render a <code>div</code> element which wraps an <code>h1</code> tag.');"
        },
        {
          "text": "A keydown listener should be attached to the document in <code>componentDidMount</code>.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const didMountString = mockedComponent.instance().componentDidMount.toString(); return new RegExp('document\\.addEventListener(.|\\n|\\r)+keydown(.|\\n|\\r)+this\\.handleKeyPress').test(didMountString); })(), 'A keydown listener should be attached to the document in <code>componentDidMount</code>.');"
        },
        {
          "text": "The keydown listener should be removed from the document in <code>componentWillUnmount</code>.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const willUnmountString = mockedComponent.instance().componentWillUnmount.toString(); return new RegExp('document\\.removeEventListener(.|\\n|\\r)+keydown(.|\\n|\\r)+this\\.handleKeyPress').test(willUnmountString); })(), 'The keydown listener should be removed from the document in <code>componentWillUnmount</code>.');"
        },
        {
          "text": "Once the component has mounted, pressing <code>enter</code> should update its state and the rendered <code>h1</code> tag.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const beforeState = mockedComponent.state('message'); const beforeText = mockedComponent.find('h1').text(); const pressEnterKey = () => { mockedComponent.instance().handleKeyPress({ keyCode: 13 }); return waitForIt(() => { mockedComponent.update(); return { state: mockedComponent.state('message'), text: mockedComponent.find('h1').text()}; });}; const afterKeyPress = await pressEnterKey(); assert(beforeState !== afterKeyPress.state && beforeText !== afterKeyPress.text, 'Once the component has mounted, pressing <code>enter</code> should update its state and the rendered <code>h1</code> tag.'); }; "
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: ''\n    };\n    this.handleKeyPress = this.handleKeyPress.bind(this);\n    this.handleEnter = this.handleEnter.bind(this);  }\n  componentDidMount() {\n    // change code below this line\n    document.addEventListener('keydown', this.handleKeyPress);\n    // change code above this line\n  }\n  componentWillUnmount() {\n    // change code below this line\n    document.removeEventListener('keydown', this.handleKeyPress);\n    // change code above this line\n  }\n  handleEnter() {\n    this.setState({\n      message: this.state.message + 'You pressed the enter key! '\n    });\n  }\n  handleKeyPress(event) {\n    if (event.keyCode === 13) {\n      this.handleEnter();\n    }\n  }\n  render() {\n    return (\n      <div>\n        <h1>{this.state.message}</h1>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403617f",
      "title": "Manage Updates with Lifecycle Methods",
      "releasedOn": "December 25, 2017",
      "description": [
        "Another lifecycle method is <code>componentWillReceiveProps()</code> which is called whenever a component is receiving new props. This method receives the new props as an argument, which is usually written as <code>nextProps</code>. You can use this argument and compare with <code>this.props</code> and perform actions before the component updates. For example, you may call <code>setState()</code> locally before the update is processed.",
        "Another method is <code>componentDidUpdate()</code>, and is called immediately after a component re-renders. Note that rendering and mounting are considered different things in the component lifecycle. When a page first loads, all components are mounted and this is where methods like <code>componentWillMount()</code> and <code>componentDidMount()</code> are called. After this, as state changes, components re-render themselves. The next challenge covers this in more detail.",
        "<hr>",
        "The child component <code>Dialog</code> receives <code>message</code> props from its parent, the <code>Controller</code>组件。 Write the <code>componentWillReceiveProps()</code> method in the <code>Dialog</code> component and have it log <code>this.props</code> and <code>nextProps</code> to the console. You'll need to pass <code>nextProps</code> as an argument to this method and although it's possible to name it anything, name it <code>nextProps</code> here.",
        "Next, add <code>componentDidUpdate()</code> in the <code>Dialog</code> component, and log a statement that says the component has updated. This method works similar to <code>componentWillUpdate()</code>, which is provided for you. Now click the button to change the message and watch your browser console. The order of the console statements show the order the methods are called.",
        "<strong>Note:</strong>&nbsp;You'll need to write the lifecycle methods as normal functions and not as arrow functions to pass the tests (there is also no advantage to writing lifecycle methods as arrow functions)."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class Dialog extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  componentWillUpdate() {",
            "    console.log('Component is about to update...');",
            "  }",
            "  // change code below this line",
            "",
            "  // change code above this line",
            "  render() {",
            "    return <h1>{this.props.message}</h1>",
            "  }",
            "};",
            "",
            "class Controller extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      message: 'First Message'",
            "    };",
            "    this.changeMessage = this.changeMessage.bind(this);",
            "  }",
            "  changeMessage() {",
            "    this.setState({",
            "      message: 'Second Message'",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <button onClick={this.changeMessage}>Update</button>",
            "        <Dialog message={this.state.message}/>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<Controller />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>Controller</code> component should render the <code>Dialog</code> component as a child.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Controller)); return mockedComponent.find('Controller').length === 1 && mockedComponent.find('Dialog').length === 1; })(), 'The <code>Controller</code> component should render the <code>Dialog</code> component as a child.');"
        },
        {
          "text": "The <code>componentWillReceiveProps</code> method in the <code>Dialog</code> component should log <code>this.props</code> to the console.",
          "testString": "assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentWillReceiveProps.toString().replace(/ /g,''); return lifecycleChild.includes('console.log') && lifecycleChild.includes('this.props') })(), 'The <code>componentWillReceiveProps</code> method in the <code>Dialog</code> component should log <code>this.props</code> to the console.');"
        },
        {
          "text": "The <code>componentWillReceiveProps</code> method in the <code>Dialog</code> component should log <code>nextProps</code> to the console.",
          "testString": "assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentWillReceiveProps.toString().replace(/ /g,''); const nextPropsAsParameterTest = /componentWillReceiveProps(| *?= *?)(\\(|)nextProps(\\)|)( *?=> *?{| *?{|{)/; const nextPropsInConsoleLogTest = /console\\.log\\(.*?nextProps\\b.*?\\)/; return ( lifecycleChild.includes('console.log') && nextPropsInConsoleLogTest.test(lifecycleChild) && nextPropsAsParameterTest.test(lifecycleChild) ); })(), 'The <code>componentWillReceiveProps</code> method in the <code>Dialog</code> component should log <code>nextProps</code> to the console.');"
        },
        {
          "text": "The <code>Dialog</code> component should call the <code>componentDidUpdate</code> method and log a message to the console.",
          "testString": "assert((function() { const lifecycleChild = React.createElement(Dialog).type.prototype.componentDidUpdate.toString().replace(/ /g,''); return lifecycleChild.length !== 'undefined' && lifecycleChild.includes('console.log'); })(), 'The <code>Dialog</code> component should call the <code>componentDidUpdate</code> method and log a message to the console.');"
        }
      ],
      "solutions": [
        "class Dialog extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  componentWillUpdate() {\n    console.log('Component is about to update...');\n  }\n  // change code below this line\n  componentWillReceiveProps(nextProps) {\n    console.log(this.props, nextProps);\n  }\n  componentDidUpdate() {\n    console.log('Component re-rendered');\n  }\n  // change code above this line\n  render() {\n    return <h1>{this.props.message}</h1>\n  }\n};\n\nclass Controller extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      message: 'First Message'\n    };\n this.changeMessage = this.changeMessage.bind(this); \n  }\n  changeMessage() {\n    this.setState({\n      message: 'Second Message'\n    });\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={this.changeMessage}>Update</button>\n        <Dialog message={this.state.message}/>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036180",
      "title": "Optimize Re-Renders with shouldComponentUpdate",
      "releasedOn": "December 25, 2017",
      "description": [
        "So far, if any component receives new <code>state</code> or new <code>props</code>, it re-renders itself and all its children. This is usually okay. But React provides a lifecycle method you can call when child components receive new <code>state</code> or <code>props</code>, and declare specifically if the components should update or not. The method is <code>shouldComponentUpdate()</code>, and it takes <code>nextProps</code> and <code>nextState</code> as parameters.",
        "This method is a useful way to optimize performance. For example, the default behavior is that your component re-renders when it receives new <code>props</code>, even if the <code>props</code> haven't changed. You can use <code>shouldComponentUpdate()</code> to prevent this by comparing the <code>props</code>. The method must return a <code>boolean</code> value that tells React whether or not to update the组件。 You can compare the current props (<code>this.props</code>) to the next props (<code>nextProps</code>) to determine if you need to update or not, and return <code>true</code> or <code>false</code> accordingly.",
        "<hr>",
        "The <code>shouldComponentUpdate()</code> method is added in a component called <code>OnlyEvens</code>. Currently, this method returns <code>true</code> so <code>OnlyEvens</code> re-renders every time it receives new <code>props</code>. Modify the method so <code>OnlyEvens</code> updates only if the <code>value</code> of its new props is even. Click the <code>Add</code> button and watch the order of events in your browser's console as the other lifecycle hooks are triggered."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class OnlyEvens extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  shouldComponentUpdate(nextProps, nextState) {",
            "    console.log('Should I update?');",
            "     // change code below this line",
            "    return true;",
            "     // change code above this line",
            "  }",
            "  componentWillReceiveProps(nextProps) {",
            "    console.log('Receiving new props...');",
            "  }",
            "  componentDidUpdate() {",
            "    console.log('Component re-rendered.');",
            "  }",
            "  render() {",
            "    return <h1>{this.props.value}</h1>",
            "  }",
            "};",
            "",
            "class Controller extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      value: 0",
            "    };",
            "    this.addValue = this.addValue.bind(this);",
            "  }",
            "  addValue() {",
            "    this.setState({",
            "      value: this.state.value + 1",
            "    });",
            "  }",
            "  render() {",
            "    return (",
            "      <div>",
            "        <button onClick={this.addValue}>Add</button>",
            "        <OnlyEvens value={this.state.value}/>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<Controller />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>Controller</code> component should render the <code>OnlyEvens</code> component as a child.",
          "testString": "assert((() => { const mockedComponent = Enzyme.mount(React.createElement(Controller)); return mockedComponent.find('Controller').length === 1 && mockedComponent.find('OnlyEvens').length === 1; })(), 'The <code>Controller</code> component should render the <code>OnlyEvens</code> component as a child.');"
        },
        {
          "text": "The <code>shouldComponentUpdate</code> method should be defined on the <code>OnlyEvens</code>组件。",
          "testString": "assert((() => { const child = React.createElement(OnlyEvens).type.prototype.shouldComponentUpdate.toString().replace(/s/g,''); return child !== 'undefined'; })(), 'The <code>shouldComponentUpdate</code> method should be defined on the <code>OnlyEvens</code>组件。');"
        },
        {
          "text": "The <code>OnlyEvens</code> component should return an <code>h1</code> tag which renders the value of <code>this.props.value</code>.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(Controller)); const first = () => { mockedComponent.setState({ value: 1000 }); return waitForIt(() => mockedComponent.find('h1').html()); }; const second = () => { mockedComponent.setState({ value: 10 }); return waitForIt(() => mockedComponent.find('h1').html()); }; const firstValue = await first(); const secondValue = await second(); assert(firstValue === '<h1>1000</h1>' && secondValue === '<h1>10</h1>', 'The <code>OnlyEvens</code> component should return an <code>h1</code> tag which renders the value of <code>this.props.value</code>.'); }; "
        },
        {
          "text": "<code>OnlyEvens</code> should re-render only when <code>nextProps.value</code> is even.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(Controller)); const first = () => { mockedComponent.setState({ value: 8 }); return waitForIt(() => mockedComponent.find('h1').text()); }; const second = () => { mockedComponent.setState({ value: 7 }); return waitForIt(() => mockedComponent.find('h1').text()); }; const third = () => { mockedComponent.setState({ value: 42 }); return waitForIt(() => mockedComponent.find('h1').text()); }; const firstValue = await first(); const secondValue = await second(); const thirdValue = await third(); assert(firstValue === '8' && secondValue === '8' && thirdValue === '42', '<code>OnlyEvens</code> should re-render only when <code>nextProps.value</code> is even.'); }; "
        }
      ],
      "solutions": [
        "class OnlyEvens extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    console.log('Should I update?');\n    // change code below this line\n    return nextProps.value % 2 === 0;\n    // change code above this line\n  }\n  componentWillReceiveProps(nextProps) {\n    console.log('Receiving new props...');\n  }\n  componentDidUpdate() {\n    console.log('Component re-rendered.');\n  }\n  render() {\n    return <h1>{this.props.value}</h1>\n  }\n};\n\nclass Controller extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      value: 0\n    };\n  this.addValue = this.addValue.bind(this);\n  }\n  addValue() {\n    this.setState({\n      value: this.state.value + 1\n    });\n  }\n  render() {\n    return (\n      <div>\n        <button onClick={this.addValue}>Add</button>\n        <OnlyEvens value={this.state.value}/>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036181",
      "title": "Introducing Inline Styles",
      "releasedOn": "December 25, 2017",
      "description": [
        "There are other complex concepts that add powerful capabilities to your React code. But you may be wondering about the more simple problem of how to style those JSX elements you create in React. You likely know that it won't be exactly the same as working with HTML because of <a target=\"_blank\" href=\"define-an-html-class-in-jsx\"> the way you apply classes to JSX elements</a>.",
        "If you import styles from a stylesheet, it isn't much different at all. You apply a class to your JSX element using the <code>className</code> attribute, and apply styles to the class in your stylesheet. Another option is to apply <strong><em>inline</em></strong> styles, which are very common in ReactJS development.",
        "You apply inline styles to JSX elements similar to how you do it in HTML, but with a few JSX differences. Here's an example of an inline style in HTML:",
        "<code>&lt;div style=\"color: yellow; font-size: 16px\"&gt;Mellow Yellow&lt;/div&gt;</code>",
        "JSX elements use the <code>style</code> attribute, but because of the way JSX is transpiled, you can't set the value to a <code>string</code>. Instead, you set it equal to a JavaScript <code>object</code>. Here's an example:",
        "<code>&lt;div style={{color: \"yellow\", fontSize: 16}}&gt;Mellow Yellow&lt;/div&gt;</code>",
        "Notice how we camelCase the \"fontSize\" property? This is because React will not accept kebab-case keys in the style object. React will apply the correct property name for us in the HTML.",
        "<hr>",
        "Add a <code>style</code> attribute to the <code>div</code> in the code editor to give the text a color of red and font size of 72px.",
        "Note that you can optionally set the font size to be a number, omitting the units \"px\", or write it as \"72px\"."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "class Colorful extends React.Component {",
            "  render() {",
            "    return (",
            "      <div>Big Red</div>",
            "    );",
            "  }",
            "};",
            ""
          ],
          "tail": [
            "ReactDOM.render(<Colorful />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The component should render a <code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Colorful)); return mockedComponent.children().type() === 'div'; })(), 'The component should render a <code>div</code>元素。');"
        },
        {
          "text": "The <code>div</code> element should have a color of <code>red</code>.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Colorful)); return mockedComponent.children().props().style.color === 'red'; })(), 'The <code>div</code> element should have a color of <code>red</code>.');"
        },
        {
          "text": "The <code>div</code> element should have a font size of <code>72px</code>.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(Colorful)); return (mockedComponent.children().props().style.fontSize === 72 || mockedComponent.children().props().style.fontSize === '72' || mockedComponent.children().props().style.fontSize === '72px'); })(), 'The <code>div</code> element should have a font size of <code>72px</code>.');"
        }
      ],
      "solutions": [
        "class Colorful extends React.Component {\n  render() {\n    return (\n      <div style={{color: \"red\", fontSize: 72}}>Big Red</div>\n    );\n  }\n};\n"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036182",
      "title": "Add Inline Styles in React",
      "releasedOn": "December 25, 2017",
      "description": [
        "You may have noticed in the last challenge that there were several other syntax differences from HTML inline styles in addition to the <code>style</code> attribute set to a JavaScript object. First, the names of certain CSS style properties use camel case. For example, the last challenge set the size of the font with <code>fontSize</code> instead of <code>font-size</code>. Hyphenated words like <code>font-size</code> are invalid syntax for JavaScript object properties, so React uses camel case. As a rule, any hyphenated style properties are written using camel case in JSX.",
        "All property value length units (like <code>height</code>, <code>width</code>, and <code>fontSize</code>) are assumed to be in <code>px</code> unless otherwise specified. If you want to use <code>em</code>, for example, you wrap the value and the units in quotes, like <code>{fontSize: \"4em\"}</code>. Other than the length values that default to <code>px</code>, all other property values should be wrapped in quotes.",
        "<hr>",
        "If you have a large set of styles, you can assign a style <code>object</code> to a constant to keep your code organized. Uncomment the <code>styles</code> constant and declare an <code>object</code> with three style properties and their values. Give the <code>div</code> a color of <code>\"purple\"</code>, a font-size of <code>40</code>, and a border of <code>\"2px solid purple\"</code>. Then set the <code>style</code> attribute equal to the <code>styles</code> constant."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "// const styles =",
            "// change code above this line",
            "class Colorful extends React.Component {",
            "  render() {",
            "    // change code below this line",
            "    return (",
            "      <div style={{color: \"yellow\", fontSize: 24}}>Style Me!</div>",
            "    );",
            "    // change code above this line",
            "  }",
            "};",
            ""
          ],
          "tail": [
            "ReactDOM.render(<Colorful />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>styles</code> variable should be an <code>object</code> with three properties.",
          "testString": "assert(Object.keys(styles).length === 3, 'The <code>styles</code> variable should be an <code>object</code> with three properties.');"
        },
        {
          "text": "The <code>styles</code> variable should have a <code>color</code> property set to a value of <code>purple</code>.",
          "testString": "assert(styles.color === 'purple', 'The <code>styles</code> variable should have a <code>color</code> property set to a value of <code>purple</code>.');"
        },
        {
          "text": "The <code>styles</code> variable should have a <code>fontSize</code> property set to a value of <code>40</code>.",
          "testString": "assert(styles.fontSize === 40, 'The <code>styles</code> variable should have a <code>fontSize</code> property set to a value of <code>40</code>.');"
        },
        {
          "text": "The <code>styles</code> variable should have a <code>border</code> property set to a value of <code>2px solid purple</code>.",
          "testString": "assert(styles.border === \"2px solid purple\", 'The <code>styles</code> variable should have a <code>border</code> property set to a value of <code>2px solid purple</code>.');"
        },
        {
          "text": "The component should render a <code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.shallow(React.createElement(Colorful)); return mockedComponent.type() === 'div'; })(), 'The component should render a <code>div</code>元素。');"
        },
        {
          "text": "The <code>div</code> element should have its styles defined by the <code>styles</code> object.",
          "testString": "assert((function() { const mockedComponent = Enzyme.shallow(React.createElement(Colorful)); return (mockedComponent.props().style.color === \"purple\" && mockedComponent.props().style.fontSize === 40 && mockedComponent.props().style.border === \"2px solid purple\"); })(), 'The <code>div</code> element should have its styles defined by the <code>styles</code> object.');"
        }
      ],
      "solutions": [
        "const styles = {\n  color: \"purple\",\n  fontSize: 40,\n  border: \"2px solid purple\"\n};\n// change code above this line\nclass Colorful extends React.Component {\n  render() {\n    // change code below this line\n    return (\n      <div style={styles}>Style Me!</div>\n  // change code above this line\n    );\n  }\n};\n"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036183",
      "title": "Use Advanced JavaScript in React Render Method",
      "releasedOn": "December 25, 2017",
      "description": [
        "In previous challenges, you learned how to inject JavaScript code into JSX code using curly braces, <code>{ }</code>, for tasks like accessing props, passing props, accessing state, inserting comments into your code, and most recently, styling your components. These are all common use cases to put JavaScript in JSX, but they aren't the only way that you can utilize JavaScript code in your React components.",
        "You can also write JavaScript directly in your <code>render</code> methods, before the <code>return</code> statement, <strong><em>without</em></strong> inserting it inside of curly braces. This is because it is not yet within the JSX code. When you want to use a variable later in the JSX code <em>inside</em> the <code>return</code> statement, you place the variable name inside curly braces.",
        "<hr>",
        "In the code provided, the <code>render</code> method has an array that contains 20 phrases to represent the answers found in the classic 1980's Magic Eight Ball toy. The button click event is bound to the <code>ask</code> method, so each time the button is clicked a random number will be generated and stored as the <code>randomIndex</code> in state. On line 52, delete the string <code>\"change me!\"</code> and reassign the <code>answer</code> const so your code randomly accesses a different index of the <code>possibleAnswers</code> array each time the component updates. Finally, insert the <code>answer</code> const inside the <code>p</code> tags."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const inputStyle = {",
            "  width: 235,",
            "  margin: 5",
            "}",
            "",
            "class MagicEightBall extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      userInput: '',",
            "      randomIndex: ''",
            "    }",
            "    this.ask = this.ask.bind(this);",
            "    this.handleChange = this.handleChange.bind(this);",
            "  }",
            "  ask() {",
            "    if (this.state.userInput) {",
            "      this.setState({",
            "        randomIndex: Math.floor(Math.random() * 20),",
            "        userInput: ''",
            "      });",
            "    }",
            "  }",
            "  handleChange(event) {",
            "    this.setState({",
            "      userInput: event.target.value",
            "    });",
            "  }",
            "  render() {",
            "    const possibleAnswers = [",
            "      'It is certain',",
            "      'It is decidedly so',",
            "      'Without a doubt', ",
            "      'Yes, definitely',",
            "      'You may rely on it',",
            "      'As I see it, yes',",
            "      'Outlook good',",
            "      'Yes',",
            "      'Signs point to yes',",
            "      'Reply hazy try again',",
            "      'Ask again later',",
            "      'Better not tell you now',",
            "      'Cannot predict now',",
            "      'Concentrate and ask again',",
            "      'Don\\'t count on it', ",
            "      'My reply is no',",
            "      'My sources say no',",
            "      'Most likely',",
            "      'Outlook not so good',",
            "      'Very doubtful'",
            "    ];",
            "    const answer = 'change me!' // << change code here",
            "    return (",
            "      <div>",
            "        <input",
            "          type=\"text\"",
            "          value={this.state.userInput}",
            "          onChange={this.handleChange}",
            "          style={inputStyle} /><br />",
            "        <button onClick={this.ask}>",
            "          Ask the Magic Eight Ball!",
            "        </button><br />",
            "        <h3>Answer:</h3>",
            "        <p>",
            "          { /* change code below this line */ }",
            "",
            "          { /* change code above this line */ }",
            "        </p>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "var possibleAnswers = [ 'It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely', 'You may rely on it', 'As I see it, yes', 'Outlook good', 'Yes', 'Signs point to yes', 'Reply hazy try again', 'Ask again later', 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again', 'Don\\'t count on it', 'My reply is no', 'My sources say no', 'Outlook not so good','Very doubtful', 'Most likely' ];",
            "ReactDOM.render(<MagicEightBall />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>MagicEightBall</code> component should exist and should render to the page.",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(MagicEightBall)).find('MagicEightBall').length, 1, 'The <code>MagicEightBall</code> component should exist and should render to the page.');"
        },
        {
          "text": "<code>MagicEightBall</code>&apos;s first child should be an <code>input</code>元素。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(MagicEightBall)).children().childAt(0).name(), 'input', '<code>MagicEightBall</code>&apos;s first child should be an <code>input</code>元素。');"
        },
        {
          "text": "<code>MagicEightBall</code>&apos;s third child should be a <code>button</code>元素。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(MagicEightBall)).children().childAt(2).name(), 'button', '<code>MagicEightBall</code>&apos;s third child should be a <code>button</code>元素。');"
        },
        {
          "text": "<code>MagicEightBall</code>&apos;s state should be initialized with a property of <code>userInput</code> and a property of <code>randomIndex</code> both set to a value of an empty string.",
          "testString": "assert(Enzyme.mount(React.createElement(MagicEightBall)).state('randomIndex') === '' && Enzyme.mount(React.createElement(MagicEightBall)).state('userInput') === '', '<code>MagicEightBall</code>&apos;s state should be initialized with a property of <code>userInput</code> and a property of <code>randomIndex</code> both set to a value of an empty string.');"
        },
        {
          "text": "When <code>MagicEightBall</code> is first mounted to the DOM, it should return an empty <code>p</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(MagicEightBall)).find('p').length === 1 && Enzyme.mount(React.createElement(MagicEightBall)).find('p').text() === '', 'When <code>MagicEightBall</code> is first mounted to the DOM, it should return an empty <code>p</code>元素。');"
        },
        {
          "text": "When text is entered into the <code>input</code> element and the button is clicked, the <code>MagicEightBall</code> component should return a <code>p</code> element that contains a random element from the <code>possibleAnswers</code> array.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const comp = Enzyme.mount(React.createElement(MagicEightBall)); const simulate = () => { comp.find('input').simulate('change', { target: { value: 'test?' }}); comp.find('button').simulate('click'); }; const result = () => comp.find('p').text(); const _1 = () => { simulate(); return waitForIt(() => result()) }; const _2 = () => { simulate(); return waitForIt(() => result()) }; const _3 = () => { simulate(); return waitForIt(() => result()) }; const _4 = () => { simulate(); return waitForIt(() => result()) }; const _5 = () => { simulate(); return waitForIt(() => result()) }; const _6 = () => { simulate(); return waitForIt(() => result()) }; const _7 = () => { simulate(); return waitForIt(() => result()) }; const _8 = () => { simulate(); return waitForIt(() => result()) }; const _9 = () => { simulate(); return waitForIt(() => result()) }; const _10 = () => { simulate(); return waitForIt(() => result()) }; const _1_val = await _1(); const _2_val = await _2(); const _3_val = await _3(); const _4_val = await _4(); const _5_val = await _5(); const _6_val = await _6(); const _7_val = await _7(); const _8_val = await _8(); const _9_val = await _9(); const _10_val = await _10(); const actualAnswers = [_1_val, _2_val, _3_val, _4_val, _5_val, _6_val, _7_val, _8_val, _9_val, _10_val]; const hasIndex = actualAnswers.filter((answer, i) => possibleAnswers.indexOf(answer) !== -1); const notAllEqual = new Set(actualAnswers); assert(notAllEqual.size > 1 && hasIndex.length === 10, 'When text is entered into the <code>input</code> element and the button is clicked, the <code>MagicEightBall</code> component should return a <code>p</code> element that contains a random element from the <code>possibleAnswers</code> array.');}"
        }
      ],
      "solutions": [
        "const inputStyle = {\n  width: 235,\n  margin: 5\n}\n\nclass MagicEightBall extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      userInput: '',\n      randomIndex: ''\n    }\n    this.ask = this.ask.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n  }\n  ask() {\n    if (this.state.userInput) {\n      this.setState({\n        randomIndex: Math.floor(Math.random() * 20),\n        userInput: ''\n      });\n    }\n  }\n  handleChange(event) {\n    this.setState({\n      userInput: event.target.value\n    });\n  }\n  render() {\n    const possibleAnswers = [\n      \"It is certain\", \"It is decidedly so\", \"Without a doubt\",\n      \"Yes, definitely\", \"You may rely on it\", \"As I see it, yes\",\n      \"Outlook good\", \"Yes\", \"Signs point to yes\", \"Reply hazy try again\",\n      \"Ask again later\", \"Better not tell you now\", \"Cannot predict now\",\n      \"Concentrate and ask again\", \"Don't count on it\", \"My reply is no\",\n      \"My sources say no\", \"Outlook not so good\",\"Very doubtful\", \"Most likely\"\n    ];\n    const answer = possibleAnswers[this.state.randomIndex];\n    return (\n      <div>\n        <input\n          type=\"text\"\n          value={this.state.userInput}\n          onChange={this.handleChange}\n          style={inputStyle} /><br />\n        <button onClick={this.ask}>Ask the Magic Eight Ball!</button><br />\n        <h3>Answer:</h3>\n        <p>\n          {answer}\n        </p>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036184",
      "title": "Render with an If/Else Condition",
      "releasedOn": "December 25, 2017",
      "description": [
        "Another application of using JavaScript to control your rendered view is to tie the elements that are rendered to a condition. When the condition is true, one view renders. When it's false, it's a different view. You can do this with a standard <code>if/else</code> statement in the <code>render()</code> method of a React组件。",
        "<hr>",
        "MyComponent contains a <code>boolean</code> in its state which tracks whether you want to display some element in the UI or not. The <code>button</code> toggles the state of this value. Currently, it renders the same UI every time. Rewrite the <code>render()</code> method with an <code>if/else</code> statement so that if <code>display</code> is <code>true</code>, you return the current markup. Otherwise, return the markup without the <code>h1</code>元素。",
        "<strong>Note:</strong>&nbsp;You must write an <code>if/else</code> to pass the tests. Use of the ternary operator will not pass here."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      display: true",
            "    }",
            "    this.toggleDisplay = this.toggleDisplay.bind(this);",
            "  }",
            "  toggleDisplay() {",
            "    this.setState({",
            "      display: !this.state.display",
            "    });",
            "  }",
            "  render() {",
            "    // change code below this line",
            "",
            "    return (",
            "       <div>",
            "         <button onClick={this.toggleDisplay}>Toggle Display</button>",
            "         <h1>Displayed!</h1>",
            "       </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code> should exist and render.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.find('MyComponent').length === 1; })(), '<code>MyComponent</code> should exist and render.');"
        },
        {
          "text": "When <code>display</code> is set to <code>true</code>, a <code>div</code>, <code>button</code>, and <code>h1</code> should render.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const state_1 = () => { mockedComponent.setState({display: true}); return waitForIt(() => mockedComponent )}; const updated = await state_1(); assert(mockedComponent.find('div').length === 1 && mockedComponent.find('div').children().length === 2 && mockedComponent.find('button').length === 1 && mockedComponent.find('h1').length === 1, 'When <code>display</code> is set to <code>true</code>, a <code>div</code>, <code>button</code>, and <code>h1</code> should render.'); }; "
        },
        {
          "text": "When <code>display</code> is set to <code>false</code>, only a <code>div</code> and <code>button</code> should render.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const state_1 = () => { mockedComponent.setState({display: false}); return waitForIt(() => mockedComponent )}; const updated = await state_1(); assert(mockedComponent.find('div').length === 1 && mockedComponent.find('div').children().length === 1 && mockedComponent.find('button').length === 1 && mockedComponent.find('h1').length === 0, 'When <code>display</code> is set to <code>false</code>, only a <code>div</code> and <code>button</code> should render.'); }; "
        },
        {
          "text": "The render method should use an <code>if/else</code> statement to check the condition of <code>this.state.display</code>.",
          "testString": "getUserInput => assert(getUserInput('index').includes('if') && getUserInput('index').includes('else'), 'The render method should use an <code>if/else</code> statement to check the condition of <code>this.state.display</code>.');"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      display: true\n    }\n this.toggleDisplay = this.toggleDisplay.bind(this); \n }\n  toggleDisplay() {\n    this.setState({\n      display: !this.state.display\n    });\n  }\n  render() {\n    // change code below this line\n    if (this.state.display) {\n      return (\n         <div>\n           <button onClick={this.toggleDisplay}>Toggle Display</button>\n           <h1>Displayed!</h1>\n         </div>\n      );\n    } else {\n      return (\n        <div>\n           <button onClick={this.toggleDisplay}>Toggle Display</button>\n         </div>\n      );\n    }\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036185",
      "title": "Use && for a More Concise Conditional",
      "releasedOn": "December 25, 2017",
      "description": [
        "The if/else statements worked in the last challenge, but there's a more concise way to achieve the same result. Imagine that you are tracking several conditions in a component and you want different elements to render depending on each of these conditions. If you write a lot of <code>else if</code> statements to return slightly different UIs, you may repeat code which leaves room for error. Instead, you can use the <code>&&</code> logical operator to perform conditional logic in a more concise way. This is possible because you want to check if a condition is <code>true</code>, and if it is, return some markup. Here's an example:",
        "<code>{condition && &lt;p&gt;markup&lt;/p&gt;}</code>",
        "If the <code>condition</code> is <code>true</code>, the markup will be returned. If the condition is <code>false</code>, the operation will immediately return <code>false</code> after evaluating the <code>condition</code> and return nothing. You can include these statements directly in your JSX and string multiple conditions together by writing <code>&&</code> after each one. This allows you to handle more complex conditional logic in your <code>render()</code> method without repeating a lot of code.",
        "<hr>",
        "Solve the previous example again, so the <code>h1</code> only renders if <code>display</code> is <code>true</code>, but use the <code>&&</code> logical operator instead of an <code>if/else</code> statement."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      display: true",
            "    }",
            "    this.toggleDisplay = this.toggleDisplay.bind(this);",
            "  }",
            "  toggleDisplay() {",
            "    this.setState({",
            "      display: !this.state.display",
            "    });",
            "  }",
            "  render() {",
            "    // change code below this line",
            "    return (",
            "       <div>",
            "         <button onClick={this.toggleDisplay}>Toggle Display</button>",
            "         <h1>Displayed!</h1>",
            "       </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code> should exist and render.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); return mockedComponent.find('MyComponent').length; })(), '<code>MyComponent</code> should exist and render.');"
        },
        {
          "text": "When <code>display</code> is set to <code>true</code>, a <code>div</code>, <code>button</code>, and <code>h1</code> should render.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const state_1 = () => { mockedComponent.setState({display: true}); return waitForIt(() => mockedComponent )}; const updated = await state_1(); assert(updated.find('div').length === 1 && updated.find('div').children().length === 2 && updated.find('button').length === 1 && updated.find('h1').length === 1, 'When <code>display</code> is set to <code>true</code>, a <code>div</code>, <code>button</code>, and <code>h1</code> should render.'); }; "
        },
        {
          "text": "When <code>display</code> is set to <code>false</code>, only a <code>div</code> and <code>button</code> should render.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(MyComponent)); const state_1 = () => { mockedComponent.setState({display: false}); return waitForIt(() => mockedComponent )}; const updated = await state_1(); assert(updated.find('div').length === 1 && updated.find('div').children().length === 1 && updated.find('button').length === 1 && updated.find('h1').length === 0, 'When <code>display</code> is set to <code>false</code>, only a <code>div</code> and <code>button</code> should render.'); }; "
        },
        {
          "text": "The render method should use the && logical operator to check the condition of this.state.display.",
          "testString": "getUserInput => assert(getUserInput('index').includes('&&'), 'The render method should use the && logical operator to check the condition of this.state.display.');"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      display: true\n    }\n this.toggleDisplay = this.toggleDisplay.bind(this); \n  }\n  toggleDisplay() {\n    this.setState({\n      display: !this.state.display\n    });\n  }\n  render() {\n    // change code below this line\n    return (\n       <div>\n         <button onClick={this.toggleDisplay}>Toggle Display</button>\n         {this.state.display && <h1>Displayed!</h1>}\n       </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036187",
      "title": "Use a Ternary Expression for Conditional Rendering",
      "releasedOn": "December 25, 2017",
      "description": [
        "Before moving on to dynamic rendering techniques, there's one last way to use built-in JavaScript conditionals to render what you want: the <em><strong>ternary operator</strong></em>. The ternary operator is often utilized as a shortcut for <code>if/else</code> statements in JavaScript. They're not quite as robust as traditional <code>if/else</code> statements, but they are very popular among React developers. One reason for this is because of how JSX is compiled, <code>if/else</code> statements can't be inserted directly into JSX code. You might have noticed this a couple challenges ago &mdash; when an <code>if/else</code> statement was required, it was always <em>outside</em> the <code>return</code> statement. Ternary expressions can be an excellent alternative if you want to implement conditional logic within your JSX. Recall that a ternary operator has three parts, but you can combine several ternary expressions together. Here's the basic syntax:",
        "<blockquote>condition ? expressionIfTrue : expressionIfFalse</blockquote>",
        "<hr>",
        "The code editor has three constants defined within the <code>CheckUserAge</code> component's <code>render()</code> method. They are called <code>buttonOne</code>, <code>buttonTwo</code>, and <code>buttonThree</code>. Each of these is assigned a simple JSX expression representing a button元素。 First, initialize the state of <code>CheckUserAge</code> with <code>input</code> and <code>userAge</code> both set to values of an empty string.",
        "Once the component is rendering information to the page, users should have a way to interact with it. Within the component's <code>return</code> statement, set up a ternary expression that implements the following logic: when the page first loads, render the submit button, <code>buttonOne</code>, to the page. Then, when a user enters their age and clicks the button, render a different button based on the age. If a user enters a number less than <code>18</code>, render <code>buttonThree</code>. If a user enters a number greater than or equal to <code>18</code>, render <code>buttonTwo</code>."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "const inputStyle = {",
            "  width: 235,",
            "  margin: 5",
            "}",
            "",
            "class CheckUserAge extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "    this.submit = this.submit.bind(this);",
            "    this.handleChange = this.handleChange.bind(this);",
            "  }",
            "  handleChange(e) {",
            "    this.setState({",
            "      input: e.target.value,",
            "      userAge: ''",
            "    });",
            "  }",
            "  submit() {",
            "    this.setState({",
            "      userAge: this.state.input",
            "    });",
            "  }",
            "  render() {",
            "    const buttonOne = <button onClick={this.submit}>Submit</button>;",
            "    const buttonTwo = <button>You May Enter</button>;",
            "    const buttonThree = <button>You Shall Not Pass</button>;",
            "    return (",
            "      <div>",
            "        <h3>Enter Your Age to Continue</h3>",
            "        <input",
            "          style={inputStyle}",
            "          type=\"number\"",
            "          value={this.state.input}",
            "          onChange={this.handleChange} /><br />",
            "        {",
            "          /* change code here */",
            "        }",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<CheckUserAge />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>CheckUserAge</code> component should render with a single <code>input</code> element and a single <code>button</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(CheckUserAge)).find('div').find('input').length === 1 && Enzyme.mount(React.createElement(CheckUserAge)).find('div').find('button').length === 1, 'The <code>CheckUserAge</code> component should render with a single <code>input</code> element and a single <code>button</code>元素。');"
        },
        {
          "text": "The <code>CheckUserAge</code> component&apos;s state should be initialized with a property of <code>userAge</code> and a property of <code>input</code>, both set to a value of an empty string.",
          "testString": "assert(Enzyme.mount(React.createElement(CheckUserAge)).state().input === '' && Enzyme.mount(React.createElement(CheckUserAge)).state().userAge === '', 'The <code>CheckUserAge</code> component&apos;s state should be initialized with a property of <code>userAge</code> and a property of <code>input</code>, both set to a value of an empty string.');"
        },
        {
          "text": "When the <code>CheckUserAge</code> component is first rendered to the DOM, the <code>button</code>&apos;s inner text should be Submit.",
          "testString": "assert(Enzyme.mount(React.createElement(CheckUserAge)).find('button').text() === 'Submit', 'When the <code>CheckUserAge</code> component is first rendered to the DOM, the <code>button</code>&apos;s inner text should be Submit.');"
        },
        {
          "text": "When a number of less than 18 is entered into the <code>input</code> element and the <code>button</code> is clicked, the <code>button</code>&apos;s inner text should read <code>You Shall Not Pass</code>.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(CheckUserAge)); const initialButton = mockedComponent.find('button').text(); const enter3AndClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '3' }}); mockedComponent.find('button').simulate('click'); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const enter17AndClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '17' }}); mockedComponent.find('button').simulate('click'); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const userAge3 = await enter3AndClickButton(); const userAge17 = await enter17AndClickButton(); assert(initialButton === 'Submit' && userAge3 === 'You Shall Not Pass' && userAge17 === 'You Shall Not Pass', 'When a number of less than 18 is entered into the <code>input</code> element and the <code>button</code> is clicked, the <code>button</code>&apos;s inner text should read <code>You Shall Not Pass</code>.'); }; "
        },
        {
          "text": "When a number greater than or equal to 18 is entered into the <code>input</code> element and the <code>button</code> is clicked, the <code>button</code>&apos;s inner text should read <code>You May Enter</code>.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(CheckUserAge)); const initialButton = mockedComponent.find('button').text(); const enter18AndClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '18' }}); mockedComponent.find('button').simulate('click'); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const enter35AndClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '35' }}); mockedComponent.find('button').simulate('click'); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const userAge18 = await enter18AndClickButton(); const userAge35 = await enter35AndClickButton(); assert(initialButton === 'Submit' && userAge18 === 'You May Enter' && userAge35 === 'You May Enter', 'When a number greater than or equal to 18 is entered into the <code>input</code> element and the <code>button</code> is clicked, the <code>button</code>&apos;s inner text should read <code>You May Enter</code>.'); }; "
        },
        {
          "text": "Once a number has been submitted, and the value of the <code>input</code> is once again changed, the <code>button</code> should return to reading <code>Submit</code>.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const mockedComponent = Enzyme.mount(React.createElement(CheckUserAge)); const enter18AndClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '18' }}); mockedComponent.find('button').simulate('click'); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const changeInputDontClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '5' }}); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const enter10AndClickButton = () => { mockedComponent.find('input').simulate('change', {target: { value: '10' }}); mockedComponent.find('button').simulate('click'); return waitForIt(() => { mockedComponent.update(); return mockedComponent.find('button').text(); }); }; const userAge18 = await enter18AndClickButton(); const changeInput1 = await changeInputDontClickButton(); const userAge10 = await enter10AndClickButton(); const changeInput2 = await changeInputDontClickButton(); assert(userAge18 === 'You May Enter' && changeInput1 === 'Submit' && userAge10 === 'You Shall Not Pass' && changeInput2 === 'Submit', 'Once a number has been submitted, and the value of the <code>input</code> is once again changed, the <code>button</code> should return to reading <code>Submit</code>.'); }; "
        },
        {
          "text": "Your code should not contain any <code>if/else</code> statements.",
          "testString": "assert(new RegExp(/(\\s|;)if(\\s|\\()/).test(Enzyme.mount(React.createElement(CheckUserAge)).instance().render.toString()) === false, 'Your code should not contain any <code>if/else</code> statements.');"
        }
      ],
      "solutions": [
        "const inputStyle = {\n  width: 235,\n  margin: 5\n}\n\nclass CheckUserAge extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      userAge: '',\n      input: ''\n    }\n    this.submit = this.submit.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n  }\n  handleChange(e) {\n    this.setState({\n      input: e.target.value,\n      userAge: ''\n    });\n  }\n  submit() {\n    this.setState({\n      userAge: this.state.input\n    });\n  }\n  render() {\n    const buttonOne = <button onClick={this.submit}>Submit</button>;\n    const buttonTwo = <button>You May Enter</button>;\n    const buttonThree = <button>You Shall Not Pass</button>;\n    return (\n      <div>\n        <h3>Enter Your Age to Continue</h3>\n        <input\n          style={inputStyle}\n          type=\"number\"\n          value={this.state.input}\n          onChange={this.handleChange} /><br />\n          {\n            this.state.userAge === '' ?\n            buttonOne :\n            this.state.userAge >= 18 ?\n            buttonTwo :\n            buttonThree\n          }\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036188",
      "title": "Render Conditionally from Props",
      "releasedOn": "December 25, 2017",
      "description": [
        "So far, you've seen how to use <code>if/else</code>, <code>&&,</code> <code>null</code> and the ternary operator (<code>condition ? expressionIfTrue : expressionIfFalse</code>) to make conditional decisions about what to render and when. However, there's one important topic left to discuss that lets you combine any or all of these concepts with another powerful React feature: props. Using props to conditionally render code is very common with React developers &mdash; that is, they use the value of a given prop to automatically make decisions about what to render.",
        "In this challenge, you'll set up a child component to make rendering decisions based on props. You'll also use the ternary operator, but you can see how several of the other concepts that were covered in the last few challenges might be just as useful in this context.",
        "<hr>",
        "The code editor has two components that are partially defined for you: a parent called <code>GameOfChance</code>, and a child called <code>Results</code>. They are used to create a simple game where the user presses a button to see if they win or lose.",
        "First, you'll need a simple expression that randomly returns a different value every time it is run. You can use <code>Math.random()</code>. This method returns a value between <code>0</code> (inclusive) and <code>1</code> (exclusive) each time it is called. So for 50/50 odds, use <code>Math.random() > .5</code> in your expression. Statistically speaking, this expression will return <code>true</code> 50% of the time, and <code>false</code> the other 50%. On line 30, replace the comment with this expression to complete the variable declaration.",
        "Now you have an expression that you can use to make a randomized decision in the code. Next you need to implement this. Render the <code>Results</code> component as a child of <code>GameOfChance</code>, and pass in <code>expression</code> as a prop called <code>fiftyFifty</code>. In the <code>Results</code> component, write a ternary expression to render the text <code>\"You win!\"</code> or <code>\"You lose!\"</code> based on the <code>fiftyFifty</code> prop that's being passed in from <code>GameOfChance</code>. Finally, make sure the <code>handleClick()</code> method is correctly counting each turn so the user knows how many times they've played. This also serves to let the user know the component has actually updated in case they win or lose twice in a row."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class Results extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return (",
            "      <h1>",
            "      {",
            "        /* change code here */",
            "      }",
            "      </h1>",
            "    )",
            "  };",
            "};",
            "",
            "class GameOfChance extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      counter: 1",
            "    }",
            "    this.handleClick = this.handleClick.bind(this);",
            "  }",
            "  handleClick() {",
            "    this.setState({",
            "      counter: 0 // change code here",
            "    });",
            "  }",
            "  render() {",
            "    let expression = null; // change code here",
            "    return (",
            "      <div>",
            "        <button onClick={this.handleClick}>Play Again</button>",
            "        { /* change code below this line */ }",
            "",
            "        { /* change code above this line */ }",
            "        <p>{'Turn: ' + this.state.counter}</p>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<GameOfChance />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>GameOfChance</code> component should exist and render to the page.",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(GameOfChance)).find('GameOfChance').length, 1, 'The <code>GameOfChance</code> component should exist and render to the page.');"
        },
        {
          "text": "<code>GameOfChance</code>应该返回单个<code>button</code>元素。",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(GameOfChance)).find('button').length, 1, '<code>GameOfChance</code>应该返回单个<code>button</code>元素。');"
        },
        {
          "text": "<code>GameOfChance</code>应该返回单个instance of the <code>Results</code> component, which has a prop called <code>fiftyFifty</code>.",
          "testString": "assert(Enzyme.mount(React.createElement(GameOfChance)).find('Results').length === 1 && Enzyme.mount(React.createElement(GameOfChance)).find('Results').props().hasOwnProperty('fiftyFifty') === true, '<code>GameOfChance</code>应该返回单个instance of the <code>Results</code> component, which has a prop called <code>fiftyFifty</code>.');"
        },
        {
          "text": "<code>GameOfChance</code> state should be initialized with a property of <code>counter</code> set to a value of <code>1</code>.",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(GameOfChance)).state().counter, 1, '<code>GameOfChance</code> state should be initialized with a property of <code>counter</code> set to a value of <code>1</code>.');"
        },
        {
          "text": "When the <code>GameOfChance</code> component is first rendered to the DOM, a <code>p</code> element should be returned with the inner text of <code>Turn: 1</code>.",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(GameOfChance)).find('p').text(), 'Turn: 1', 'When the <code>GameOfChance</code> component is first rendered to the DOM, a <code>p</code> element should be returned with the inner text of <code>Turn: 1</code>.');"
        },
        {
          "text": "Each time the button is clicked, the counter state should be incremented by a value of 1, and a single <code>p</code> element should be rendered to the DOM that contains the text \"Turn: N\", where N is the value of the counter state.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const comp = Enzyme.mount(React.createElement(GameOfChance)); const simulate = () => { comp.find('button').simulate('click'); };const result = () => ({ count: comp.state('counter'), text: comp.find('p').text() });const _1 = () => { simulate(); return waitForIt(() => result())}; const _2 = () => { simulate(); return waitForIt(() => result())}; const _3 = () => { simulate(); return waitForIt(() => result())}; const _4 = () => { simulate(); return waitForIt(() => result())}; const _5 = () => { simulate(); return waitForIt(() => result())}; const _1_val = await _1(); const _2_val = await _2(); const _3_val = await _3(); const _4_val = await _4(); const _5_val = await _5(); assert(_1_val.count === 2 && _1_val.text === 'Turn: 2' && _2_val.count === 3 && _2_val.text === 'Turn: 3' && _3_val.count === 4 && _3_val.text === 'Turn: 4' && _4_val.count === 5 && _4_val.text === 'Turn: 5' && _5_val.count === 6 && _5_val.text === 'Turn: 6', 'Each time the button is clicked, the counter state should be incremented by a value of 1, and a single <code>p</code> element should be rendered to the DOM that contains the text \"Turn: N\", where N is the value of the counter state.'); }; "
        },
        {
          "text": "When the <code>GameOfChance</code> component is first mounted to the DOM and each time the button is clicked thereafter, a single <code>h1</code> element should be returned that randomly renders either <code>You Win!</code> or <code>You Lose!</code>.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const comp = Enzyme.mount(React.createElement(GameOfChance)); const simulate = () => { comp.find('button').simulate('click'); };const result = () => ({ h1: comp.find('h1').length, text: comp.find('h1').text() });const _1 = result(); const _2 = () => { simulate(); return waitForIt(() => result())}; const _3 = () => { simulate(); return waitForIt(() => result())}; const _4 = () => { simulate(); return waitForIt(() => result())}; const _5 = () => { simulate(); return waitForIt(() => result())}; const _6 = () => { simulate(); return waitForIt(() => result())}; const _7 = () => { simulate(); return waitForIt(() => result())}; const _8 = () => { simulate(); return waitForIt(() => result())}; const _9 = () => { simulate(); return waitForIt(() => result())}; const _10 = () => { simulate(); return waitForIt(() => result())}; const _2_val = await _2(); const _3_val = await _3(); const _4_val = await _4(); const _5_val = await _5(); const _6_val = await _6(); const _7_val = await _7(); const _8_val = await _8(); const _9_val = await _9(); const _10_val = await _10(); const __text = new Set([_1.text, _2_val.text, _3_val.text, _4_val.text, _5_val.text, _6_val.text, _7_val.text, _8_val.text, _9_val.text, _10_val.text]); const __h1 = new Set([_1.h1, _2_val.h1, _3_val.h1, _4_val.h1, _5_val.h1, _6_val.h1, _7_val.h1, _8_val.h1, _9_val.h1, _10_val.h1]); assert(__text.size === 2 && __h1.size === 1, 'When the <code>GameOfChance</code> component is first mounted to the DOM and each time the button is clicked thereafter, a single <code>h1</code> element should be returned that randomly renders either <code>You Win!</code> or <code>You Lose!</code>.'); }; "
        }
      ],
      "solutions": [
        "class Results extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return (\n      <h1>\n      {\n        this.props.fiftyFifty ?\n        'You Win!' :\n        'You Lose!'\n      }\n      </h1>\n    )\n  };\n};\n\nclass GameOfChance extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      counter: 1\n    }\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState({\n      counter: this.state.counter + 1\n    });\n  }\n  render() {\n    const expression = Math.random() > .5;\n    return (\n      <div>\n        <button onClick={this.handleClick}>Play Again</button>\n        <Results fiftyFifty={expression} />\n        <p>{'Turn: ' + this.state.counter}</p>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d4036189",
      "title": "Change Inline CSS Conditionally Based on Component State",
      "releasedOn": "December 25, 2017",
      "description": [
        "At this point, you've seen several applications of conditional rendering and the use of inline styles. Here's one more example that combines both of these topics. You can also render CSS conditionally based on the state of a React组件。 To do this, you check for a condition, and if that condition is met, you modify the styles object that's assigned to the JSX elements in the render method.",
        "This paradigm is important to understand because it is a dramatic shift from the more traditional approach of applying styles by modifying DOM elements directly (which is very common with jQuery, for example). In that approach, you must keep track of when elements change and also handle the actual manipulation directly. It can become difficult to keep track of changes, potentially making your UI unpredictable. When you set a style object based on a condition, you describe how the UI should look as a function of the application's state. There is a clear flow of information that only moves in one direction. This is the preferred method when writing applications with React.",
        "<hr>",
        "The code editor has a simple controlled input component with a styled border. You want to style this border red if the user types more than 15 characters of text in the input box. Add a condition to check for this and, if the condition is valid, set the input border style to <code>3px solid red</code>. You can try it out by entering text in the input."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "class GateKeeper extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      input: ''",
            "    };",
            "    this.handleChange = this.handleChange.bind(this);",
            "  }",
            "  handleChange(event) {",
            "    this.setState({ input: event.target.value })",
            "  }",
            "  render() {",
            "    let inputStyle = {",
            "      border: '1px solid black'",
            "    };",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "    return (",
            "      <div>",
            "        <h3>Don't Type Too Much:</h3>",
            "        <input",
            "          type=\"text\"",
            "          style={inputStyle}",
            "          value={this.state.input}",
            "          onChange={this.handleChange} />",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<GateKeeper />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>GateKeeper</code> component should render a <code>div</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(GateKeeper)); return mockedComponent.find('div').length === 1; })(), 'The <code>GateKeeper</code> component should render a <code>div</code>元素。');"
        },
        {
          "text": "The <code>GateKeeper</code> component should be initialized with a state key <code>input</code> set to an empty string.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(GateKeeper)); return mockedComponent.state().input === ''; })(), 'The <code>GateKeeper</code> component should be initialized with a state key <code>input</code> set to an empty string.');"
        },
        {
          "text": "The <code>GateKeeper</code> component should render an <code>h3</code> tag and an <code>input</code> tag.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(GateKeeper)); return mockedComponent.find('h3').length === 1 && mockedComponent.find('input').length === 1; })(), 'The <code>GateKeeper</code> component should render an <code>h3</code> tag and an <code>input</code> tag.');"
        },
        {
          "text": "The <code>input</code> tag should initially have a style of <code>1px solid black</code> for the <code>border</code> property.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(GateKeeper)); return mockedComponent.find('input').props().style.border === '1px solid black'; })(), 'The <code>input</code> tag should initially have a style of <code>1px solid black</code> for the <code>border</code> property.');"
        },
        {
          "text": "The <code>input</code> tag should be styled with a border of <code>3px solid red</code> if the input value in state is longer than 15 characters.",
          "testString": "async () => {  const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const mockedComponent = Enzyme.mount(React.createElement(GateKeeper)); const simulateChange = (el, value) => el.simulate('change', {target: {value}}); let initialStyle = mockedComponent.find('input').props().style.border; const state_1 = () => { mockedComponent.setState({input: 'this is 15 char' }); return waitForIt(() => mockedComponent.find('input').props().style.border )}; const state_2 = () => { mockedComponent.setState({input: 'A very long string longer than 15 characters.' }); return waitForIt(() => mockedComponent.find('input').props().style.border )}; const style_1 = await state_1(); const style_2 = await state_2(); assert(initialStyle === '1px solid black' && style_1 === '1px solid black' && style_2 === '3px solid red', 'The <code>input</code> tag should be styled with a border of <code>3px solid red</code> if the input value in state is longer than 15 characters.'); }; "
        }
      ],
      "solutions": [
        "class GateKeeper extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      input: ''\n    };\n    this.handleChange = this.handleChange.bind(this);\n  }\n  handleChange(event) {\n    this.setState({ input: event.target.value })\n  }\n  render() {\n    let inputStyle = {\n      border: '1px solid black'\n    };\n    if (this.state.input.length > 15) {\n      inputStyle.border = '3px solid red';\n    };\n    return (\n      <div>\n        <h3>Don't Type Too Much:</h3>\n        <input\n          type=\"text\"\n          style={inputStyle}\n          value={this.state.input}\n          onChange={this.handleChange} />\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403618a",
      "title": "Use Array.map() to Dynamically Render Elements",
      "releasedOn": "December 25, 2017",
      "description": [
        "Conditional rendering is useful, but you may need your components to render an unknown number of elements. Often in reactive programming, a programmer has no way to know what the state of an application is until runtime, because so much depends on a user's interaction with that program. Programmers need to write their code to correctly handle that unknown state ahead of time. Using <code>Array.map()</code> in React illustrates this concept.",
        "For example, you create a simple \"To Do List\" app. As the programmer, you have no way of knowing how many items a user might have on their list. You need to set up your component to <em><strong>dynamically render</strong></em> the correct number of list elements long before someone using the program decides that today is laundry day. ",
        "<hr>",
        "The code editor has most of the <code>MyToDoList</code> component set up. Some of this code should look familiar if you completed the controlled form challenge. You'll notice a <code>textarea</code> and a <code>button</code>, along with a couple of methods that track their states, but nothing is rendered to the page yet.",
        "Inside the <code>constructor</code>, create a <code>this.state</code> object and define two states: <code>userInput</code> should be initialized as an empty string, and <code>toDoList</code> should be initialized as an empty array. Next, delete the comment in the <code>render()</code> method next to the <code>items</code> variable. In its place, map over the <code>toDoList</code> array stored in the component's internal state and dynamically render a <code>li</code> for each item. Try entering the string <code>eat, code, sleep, repeat</code> into the <code>textarea</code>, then click the button and see what happens.",
        "<strong>Note:</strong>&nbsp;You may know that all sibling child elements created by a mapping operation like this do need to be supplied with a unique <code>key</code> attribute. Don't worry, this is the topic of the next challenge."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "const textAreaStyles = {",
            "  width: 235,",
            "  margin: 5",
            "};",
            "",
            "class MyToDoList extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    // change code below this line",
            "",
            "    // change code above this line",
            "    this.handleSubmit = this.handleSubmit.bind(this);",
            "    this.handleChange = this.handleChange.bind(this);",
            "  }",
            "  handleSubmit() {",
            "    const itemsArray = this.state.userInput.split(',');",
            "    this.setState({",
            "      toDoList: itemsArray",
            "    });",
            "  }",
            "  handleChange(e) {",
            "    this.setState({",
            "      userInput: e.target.value",
            "    });",
            "  }",
            "  render() {",
            "    const items = null; // change code here",
            "    return (",
            "      <div>",
            "        <textarea",
            "          onChange={this.handleChange}",
            "          value={this.state.userInput}",
            "          style={textAreaStyles}",
            "          placeholder=\"Separate Items With Commas\" /><br />",
            "        <button onClick={this.handleSubmit}>Create List</button>",
            "        <h1>My \"To Do\" List:</h1>",
            "        <ul>",
            "          {items}",
            "        </ul>",
            "      </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyToDoList />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The MyToDoList component should exist and render to the page.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyToDoList)); return mockedComponent.find('MyToDoList').length === 1; })(), 'The MyToDoList component should exist and render to the page.');"
        },
        {
          "text": "The first child of <code>MyToDoList</code> should be a <code>textarea</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyToDoList)); return mockedComponent.find('MyToDoList').children().childAt(0).type() === 'textarea'; })(), 'The first child of <code>MyToDoList</code> should be a <code>textarea</code>元素。');"
        },
        {
          "text": "The third child of <code>MyToDoList</code> should be a <code>button</code>元素。",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyToDoList)); return mockedComponent.find('MyToDoList').children().childAt(2).type() === 'button'; })(), 'The third child of <code>MyToDoList</code> should be a <code>button</code>元素。');"
        },
        {
          "text": "The state of <code>MyToDoList</code> should be initialized with <code>toDoList</code> as an empty array.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyToDoList)); const initialState = mockedComponent.state(); return Array.isArray(initialState.toDoList) === true && initialState.toDoList.length === 0; })(), 'The state of <code>MyToDoList</code> should be initialized with <code>toDoList</code> as an empty array.');"
        },
        {
          "text": "The state of <code>MyToDoList</code> should be initialized with <code>userInput</code> as an empty string.",
          "testString": "assert((function() { const mockedComponent = Enzyme.mount(React.createElement(MyToDoList)); const initialState = mockedComponent.state(); return typeof initialState.userInput === 'string' && initialState.userInput.length === 0; })(), 'The state of <code>MyToDoList</code> should be initialized with <code>userInput</code> as an empty string.');"
        },
        {
          "text": "When the <code>Create List</code> button is clicked, the <code>MyToDoList</code> component should dynamically return an unordered list that contains a list item element for every item of a comma-separated list entered into the <code>textarea</code>元素。",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 100)); const mockedComponent = Enzyme.mount(React.createElement(MyToDoList)); const simulateChange = (el, value) => el.simulate('change', {target: {value}}); const state_1 = () => { return waitForIt(() => mockedComponent.find('ul').find('li'))}; const setInput = () => { return waitForIt(() => simulateChange(mockedComponent.find('textarea'), \"testA, testB, testC\"))}; const click = () => { return waitForIt(() => mockedComponent.find('button').simulate('click'))}; const state_2 = () => { return waitForIt(() => { const nodes = mockedComponent.find('ul').find('li'); return { nodes, text: nodes.reduce((t, n) => t + n.text(), '') }; })}; const setInput_2 = () => { return waitForIt(() => simulateChange(mockedComponent.find('textarea'), \"t1, t2, t3, t4, t5, t6\"))}; const click_1 = () => { return waitForIt(() => mockedComponent.find('button').simulate('click'))}; const state_3 = () => { return waitForIt(() => { const nodes = mockedComponent.find('ul').find('li'); return { nodes, text: nodes.reduce((t, n) => t + n.text(), '') }; })}; const awaited_state_1 = await state_1(); const awaited_setInput = await setInput(); const awaited_click = await click(); const awaited_state_2 = await state_2(); const awaited_setInput_2 = await setInput_2(); const awaited_click_1 = await click_1(); const awaited_state_3 = await state_3(); assert(awaited_state_1.length === 0 && awaited_state_2.nodes.length === 3 && awaited_state_3.nodes.length === 6 && awaited_state_2.text === 'testA testB testC' && awaited_state_3.text === 't1 t2 t3 t4 t5 t6', 'When the <code>Create List</code> button is clicked, the <code>MyToDoList</code> component should dynamically return an unordered list that contains a list item element for every item of a comma-separated list entered into the <code>textarea</code>元素。'); }; "
        }
      ],
      "solutions": [
        "const textAreaStyles = {\n  width: 235,\n  margin: 5\n};\n\nclass MyToDoList extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      toDoList: [],\n      userInput: ''\n    }\n    this.handleSubmit = this.handleSubmit.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n  }\n  handleSubmit() {\n    const itemsArray = this.state.userInput.split(',');\n    this.setState({\n      toDoList: itemsArray\n    });\n  }\n  handleChange(e) {\n    this.setState({\n      userInput: e.target.value\n    });\n  }\n  render() {\n    const items = this.state.toDoList.map( (item, i) => {\n      return <li key={i}>{item}</li>\n    });\n    return (\n      <div>\n        <textarea\n          onChange={this.handleChange}\n          value={this.state.userInput}\n          style={textAreaStyles}\n          placeholder=\"Separate Items With Commas\" /><br />\n        <button onClick={this.handleSubmit}>Create List</button>\n        <h1>My \"To Do\" List:</h1>\n        <ul>\n          {items}\n        </ul>\n      </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403618b",
      "title": "Give Sibling Elements a Unique Key Attribute",
      "releasedOn": "December 25, 2017",
      "description": [
        "The last challenge showed how the <code>map</code> method is used to dynamically render a number of elements based on user input. However, there was an important piece missing from that example. When you create an array of elements, each one needs a <code>key</code> attribute set to a unique value. React uses these keys to keep track of which items are added, changed, or removed. This helps make the re-rendering process more efficient when the list is modified in any way. Note that keys only need to be unique between sibling elements, they don't need to be globally unique in your application.",
        "<hr>",
        "The code editor has an array with some front end frameworks and a stateless functional component named <code>Frameworks()</code>. <code>Frameworks()</code> needs to map the array to an unordered list, much like in the last challenge. Finish writing the <code>map</code> callback to return an <code>li</code> element for each framework in the <code>frontEndFrameworks</code> array. This time, make sure to give each <code>li</code> a <code>key</code> attribute, set to a unique value.",
        "Normally, you want to make the key something that uniquely identifies the element being rendered. As a last resort the array index may be used, but typically you should try to use a unique identification."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "",
            "const frontEndFrameworks = [",
            "  'React',",
            "  'Angular',",
            "  'Ember',",
            "  'Knockout',",
            "  'Backbone',",
            "  'Vue'",
            "];",
            "",
            "function Frameworks() {",
            "  const renderFrameworks = null; // change code here",
            "  return (",
            "    <div>",
            "      <h1>Popular Front End JavaScript Frameworks</h1>",
            "      <ul>",
            "        {renderFrameworks}",
            "      </ul>",
            "    </div>",
            "  );",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<Frameworks />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "The <code>Frameworks</code> component should exist and render to the page.",
          "testString": "assert(Enzyme.mount(React.createElement(Frameworks)).find('Frameworks').length === 1, 'The <code>Frameworks</code> component should exist and render to the page.');"
        },
        {
          "text": "<code>Frameworks</code> should render an <code>h1</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(Frameworks)).find('h1').length === 1, '<code>Frameworks</code> should render an <code>h1</code>元素。');"
        },
        {
          "text": "<code>Frameworks</code> should render a <code>ul</code>元素。",
          "testString": "assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').length === 1, '<code>Frameworks</code> should render a <code>ul</code>元素。');"
        },
        {
          "text": "The <code>ul</code> tag should render 6 child <code>li</code> elements.",
          "testString": "assert(Enzyme.mount(React.createElement(Frameworks)).find('ul').children().length === 6 && Enzyme.mount(React.createElement(Frameworks)).find('ul').childAt(0).name() === 'li' && Enzyme.mount(React.createElement(Frameworks)).find('li').length === 6, 'The <code>ul</code> tag should render 6 child <code>li</code> elements.');"
        },
        {
          "text": "Each list item element should have a unique <code>key</code> attribute.",
          "testString": "assert((() => { const ul = Enzyme.mount(React.createElement(Frameworks)).find('ul'); const keys = new Set([ ul.childAt(0).key(), ul.childAt(1).key(), ul.childAt(2).key(), ul.childAt(3).key(), ul.childAt(4).key(), ul.childAt(5).key(), ]); return keys.size === 6; })(), 'Each list item element should have a unique <code>key</code> attribute.');"
        }
      ],
      "solutions": [
        "const frontEndFrameworks = [\n  'React',\n  'Angular',\n  'Ember',\n  'Knockout',\n  'Backbone',\n  'Vue'\n];\n\nfunction Frameworks() {\n  const renderFrameworks = frontEndFrameworks.map((fw, i) => {\n    return <li key={i}>{fw}</li>\n  })\n  return (\n    <div>\n      <h1>Popular Front End JavaScript Frameworks</h1>\n      <ul>\n        {renderFrameworks}\n      </ul>\n    </div>\n  );\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403618c",
      "title": "Use Array.filter() to Dynamically Filter an Array",
      "releasedOn": "December 25, 2017",
      "description": [
        "The <code>map</code> array method is a powerful tool that you will use often when working with React. Another method related to <code>map</code> is <code>filter</code>, which filters the contents of an array based on a condition, then returns a new array. For example, if you have an array of users that all have a property <code>online</code> which can be set to <code>true</code> or <code>false</code>, you can filter only those users that are online by writing:",
        "<code>let onlineUsers = users.filter(user => user.online);</code>",
        "<hr>",
        "In the code editor, <code>MyComponent</code>&apos;s <code>state</code> is initialized with an array of users. Some users are online and some aren't. Filter the array so you see only the users who are online. To do this, first use <code>filter</code> to return a new array containing only the users whose <code>online</code> property is <code>true</code>. Then, in the <code>renderOnline</code> variable, map over the filtered array, and return a <code>li</code> element for each user that contains the text of their <code>username</code>. Be sure to include a unique <code>key</code> as well, like in the last challenges."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "contents": [
            "class MyComponent extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "    this.state = {",
            "      users: [",
            "        {",
            "          username: 'Jeff',",
            "          online: true",
            "        },",
            "        {",
            "          username: 'Alan',",
            "          online: false",
            "        },",
            "        {",
            "          username: 'Mary',",
            "          online: true",
            "        },",
            "        {",
            "          username: 'Jim',",
            "          online: false",
            "        },",
            "        {",
            "          username: 'Sara',",
            "          online: true",
            "        },",
            "        {",
            "          username: 'Laura',",
            "          online: true",
            "        }",
            "      ]",
            "    }",
            "  }",
            "  render() {",
            "    const usersOnline = null; // change code here",
            "    const renderOnline = null; // change code here",
            "    return (",
            "       <div>",
            "         <h1>Current Online Users:</h1>",
            "         <ul>",
            "           {renderOnline}",
            "         </ul>",
            "       </div>",
            "    );",
            "  }",
            "};"
          ],
          "tail": [
            "ReactDOM.render(<MyComponent />, document.getElementById('root'))"
          ],
          "head": []
        }
      },
      "tests": [
        {
          "text": "<code>MyComponent</code> should exist and render to the page.",
          "testString": "assert.strictEqual(Enzyme.mount(React.createElement(MyComponent)).find('MyComponent').length, 1, '<code>MyComponent</code> should exist and render to the page.');"
        },
        {
          "text": "<code>MyComponent</code>&apos;s state should be initialized to an array of six users.\")",
          "testString": "assert(Array.isArray(Enzyme.mount(React.createElement(MyComponent)).state('users')) === true && Enzyme.mount(React.createElement(MyComponent)).state('users').length === 6, \"<code>MyComponent</code>&apos;s state should be initialized to an array of six users.\");"
        },
        {
          "text": "<code>MyComponent</code> should return a <code>div</code>, an <code>h1</code>, and then an unordered list containing <code>li</code> elements for every user whose online status is set to <code>true</code>.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const comp = Enzyme.mount(React.createElement(MyComponent)); const users = (bool) => ({users:[ { username: 'Jeff', online: bool }, { username: 'Alan', online: bool }, { username: 'Mary', online: bool }, { username: 'Jim', online: bool   }, { username: 'Laura', online: bool } ]}); const result = () => comp.find('li').length; const _1 = result(); const _2 = () => { comp.setState(users(true)); return waitForIt(() => result()) }; const _3 = () => { comp.setState(users(false)); return waitForIt(() => result()) }; const _4 = () => { comp.setState({ users: [] }); return waitForIt(() => result()) }; const _2_val = await _2(); const _3_val = await _3(); const _4_val = await _4(); assert(comp.find('div').length === 1 && comp.find('h1').length === 1 && comp.find('ul').length === 1 && _1 === 4 && _2_val === 5 && _3_val === 0 && _4_val === 0, '<code>MyComponent</code> should return a <code>div</code>, an <code>h1</code>, and then an unordered list containing <code>li</code> elements for every user whose online status is set to <code>true</code>.'); }; "
        },
        {
          "text": "<code>MyComponent</code> should render <code>li</code> elements that contain the username of each online user.",
          "testString": "async () => { const waitForIt = (fn) => new Promise((resolve, reject) => setTimeout(() => resolve(fn()), 250)); const comp = Enzyme.mount(React.createElement(MyComponent)); const users = (bool) => ({users:[ { username: 'Jeff', online: bool }, { username: 'Alan', online: bool }, { username: 'Mary', online: bool }, { username: 'Jim', online: bool   }, { username: 'Laura', online: bool } ]}); const ul = () => { comp.setState(users(true)); return waitForIt(() => comp.find('ul').html()) }; const html = await ul(); assert(html === '<ul><li>Jeff</li><li>Alan</li><li>Mary</li><li>Jim</li><li>Laura</li></ul>', '<code>MyComponent</code> should render <code>li</code> elements that contain the username of each online user.'); }; "
        },
        {
          "text": "Each list item element should have a unique <code>key</code> attribute.",
          "testString": "assert((() => { const ul = Enzyme.mount(React.createElement(MyComponent)).find('ul'); console.log(ul.debug()); const keys = new Set([ ul.childAt(0).key(), ul.childAt(1).key(), ul.childAt(2).key(), ul.childAt(3).key() ]); return keys.size === 4; })(), 'Each list item element should have a unique <code>key</code> attribute.');"
        }
      ],
      "solutions": [
        "class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      users: [\n        {\n          username: 'Jeff',\n          online: true\n        },\n        {\n          username: 'Alan',\n          online: false\n        },\n        {\n          username: 'Mary',\n          online: true\n        },\n        {\n          username: 'Jim',\n          online: false\n        },\n        {\n          username: 'Sara',\n          online: true\n        },\n        {\n          username: 'Laura',\n          online: true\n        }\n      ]\n    }\n  }\n  render() {\n    const usersOnline = this.state.users.filter(user => {\n      return user.online;\n    });\n    const renderOnlineUsers = usersOnline.map(user => {\n      return (\n        <li key={user.username}>{user.username}</li>\n      );\n    });\n    return (\n       <div>\n         <h1>Current Online Users:</h1>\n         <ul>\n          {renderOnlineUsers}\n        </ul>\n       </div>\n    );\n  }\n};"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    },
    {
      "id": "5a24c314108439a4d403618d",
      "title": "Render React on the Server with renderToString",
      "releasedOn": "December 25, 2017",
      "description": [
        "So far, you have been rendering React components on the client. Normally, this is what you will always do. However, there are some use cases where it makes sense to render a React component on the server. Since React is a JavaScript view library and you can run JavaScript on the server with Node, this is possible. In fact, React provides a <code>renderToString()</code> method you can use for this purpose.",
        "There are two key reasons why rendering on the server may be used in a real world app. First, without doing this, your React apps would consist of a relatively empty HTML file and a large bundle of JavaScript when it's initially loaded to the browser. This may not be ideal for search engines that are trying to index the content of your pages so people can find you. If you render the initial HTML markup on the server and send this to the client, the initial page load contains all of the page's markup which can be crawled by search engines. Second, this creates a faster initial page load experience because the rendered HTML is smaller than the JavaScript code of the entire app. React will still be able to recognize your app and manage it after the initial load.",
        "<hr>",
        "The <code>renderToString()</code> method is provided on <code>ReactDOMServer</code>, which is available here as a global object. The method takes one argument which is a React元素。 Use this to render <code>App</code> to a string."
      ],
      "files": {
        "indexjsx": {
          "key": "indexjsx",
          "ext": "jsx",
          "name": "index",
          "head": [
            "var ReactDOMServer = { renderToString(x) { return null; } };"
          ],
          "contents": [
            "",
            "class App extends React.Component {",
            "  constructor(props) {",
            "    super(props);",
            "  }",
            "  render() {",
            "    return <div/>",
            "  }",
            "};",
            "",
            "// change code below this line",
            ""
          ],
          "tail": [
            "ReactDOM.render(<App />, document.getElementById('root'))"
          ]
        }
      },
      "tests": [
        {
          "text": "The <code>App</code> component should render to a string using <code>ReactDOMServer.renderToString</code>.",
          "testString": "getUserInput => assert(getUserInput('index').replace(/ /g,'').includes('ReactDOMServer.renderToString(<App/>)') && Enzyme.mount(React.createElement(App)).children().name() === 'div', 'The <code>App</code> component should render to a string using <code>ReactDOMServer.renderToString</code>.');"
        }
      ],
      "solutions": [
        "class App extends React.Component {\n  constructor(props) {\n    super(props);\n  }\n  render() {\n    return <div/>\n  }\n};\n\n// change code below this line\nReactDOMServer.renderToString(<App/>);"
      ],
      "challengeType": 6,
      "isRequired": false,
      "react": true
    }
  ]
}